__________ ./main.go:

package main

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/adapter/out/storage/storageSQLiteAdapter"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"reflect"
)

/*
type Message struct {
	Id              string
	Timestamp       int64
	Content         string
	SenderID        string
	ReceiverID      string
	SenderAddress   string
	ReceiverAddress string
	ChatID          string
	Operation       OperationType
}
*/

func main() {

	dbPath := "test.db"

	adapter := storageSQLiteAdapter.GetInstance(dbPath)

	testMessages := []network.Message{
		{
			Id:              "msg1",
			Timestamp:       1620000000,
			Content:         "{\"message\": \"Hey everyone!\"}",
			SenderID:        "user1",
			ReceiverID:      "user2",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "user2.onion",
			ChatID:          "chat1",
			Operation:       network.SEND_MESSAGE,
		},
		{
			Id:              "sync1",
			Timestamp:       1620000060,
			Content:         "{\"existingMessageIds\": [\"msg1\"]}",
			SenderID:        "user2",
			ReceiverID:      "user1",
			SenderAddress:   "user2.onion",
			ReceiverAddress: "user1.onion",
			ChatID:          "chat1",
			Operation:       network.SYNC_REQUEST,
		},
		{
			Id:              "sync2",
			Timestamp:       1620000120,
			Content:         "[{\"Id\":\"msg2\",\"Timestamp\":1620000090,\"Content\":\"{\\\"message\\\": \\\"Hi User1!\\\"}\",\"SenderID\":\"user3\",\"ReceiverID\":\"user1\",\"SenderAddress\":\"user3.onion\",\"ReceiverAddress\":\"user1.onion\",\"ChatID\":\"chat1\",\"Operation\":0}]",
			SenderID:        "user1",
			ReceiverID:      "user2",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "user2.onion",
			ChatID:          "chat1",
			Operation:       network.SYNC_RESPONSE,
		},
		{
			Id:              "join1",
			Timestamp:       1620000180,
			Content:         "",
			SenderID:        "user4",
			ReceiverID:      "",
			SenderAddress:   "user4.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.JOIN_CHAT,
		},
		{
			Id:              "leave1",
			Timestamp:       1620000240,
			Content:         "",
			SenderID:        "user3",
			ReceiverID:      "",
			SenderAddress:   "user3.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.LEAVE_CHAT,
		},
		{
			Id:              "invite1",
			Timestamp:       1620000300,
			Content:         "{\"chatId\": \"chat1\", \"chatName\": \"Cool Chat\", \"peers\": [\"user5.onion\", \"user6.onion\"]}",
			SenderID:        "user1",
			ReceiverID:      "",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.INVITE_TO_CHAT,
		},
		{
			Id:              "file1",
			Timestamp:       1620000360,
			Content:         "{\"fileContent\": \"aGVsbG8gd29ybGQ=\"}",
			SenderID:        "user2",
			ReceiverID:      "",
			SenderAddress:   "user2.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.SEND_FILE,
		},
		{
			Id:              "setuser1",
			Timestamp:       1620000420,
			Content:         "{\"username\": \"CoolUser1\"}",
			SenderID:        "user1",
			ReceiverID:      "",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.SET_USERNAME,
		},
		{
			Id:              "test1",
			Timestamp:       1620000480,
			Content:         "This is a test message",
			SenderID:        "user1",
			ReceiverID:      "user2",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "user2.onion",
			ChatID:          "chat1",
			Operation:       network.TEST_MESSAGE,
		},
		{
			Id:              "test2",
			Timestamp:       1620000540,
			Content:         "This is another test message",
			SenderID:        "user2",
			ReceiverID:      "user4",
			SenderAddress:   "user2.onion",
			ReceiverAddress: "user4.onion",
			ChatID:          "chat1",
			Operation:       network.TEST_MESSAGE_2,
		},
	}

	// Store the test messages
	for _, msg := range testMessages {
		err := adapter.StoreMessage(msg)
		if err != nil {
			fmt.Printf("Error storing message: %v", err)
		}
	}

	fmt.Println("Messages stored")

	// Retrieve the messages and compare
	for _, msg := range testMessages {
		retrieved, err := adapter.RetrieveMessage(msg.Id)
		if err != nil {
			fmt.Printf("Error retrieving message: %v", err)
		}

		fmt.Println("storedccc ", msg)
		fmt.Println("retrieved ", retrieved)
		if !reflect.DeepEqual(msg, retrieved) {
			fmt.Printf("Retrieved message does not match stored message\n")
		}
	}

	fmt.Println("Messages retrieved")

	// Test GetChatMessages
	chatMessages, err := adapter.GetChatMessages("chat1")
	if err != nil {
		fmt.Printf("Error getting chat messages: %v", err)
	}

	if len(chatMessages) != len(testMessages) {
		fmt.Printf("Expected %d chat messages, got %d", len(testMessages), len(chatMessages))
	}

	// Test SetPeerUsername
	err = adapter.SetPeerUsername("CoolUser1", "user1", "chat1")
	if err != nil {
		fmt.Printf("Error setting peer username: %v", err)
	}

	username, err := adapter.GetUsername("user1", "chat1")
	if err != nil {
		fmt.Printf("Error getting username: %v", err)
	}

	if username != "CoolUser1" {
		fmt.Printf("Expected username 'CoolUser1', got '%s'", username)
	}

}


__________ ./skunk/adapter/in/networkMockAdapter/networkMockAdapter.go:

package networkMockAdapter

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"sync"
)

// NetworkMockAdapter is a mock adapter for the network
// It implements the NetworkConnection interface

var (
	mockConnection *MockConnection // singleton for testing purposes
	once           sync.Once
)

type MockConnection struct {
	subscribers []network.NetworkObserver
}

func GetMockConnection() *MockConnection {
	once.Do(func() {
		mockConnection = &MockConnection{}
	})
	return mockConnection
}

// SubscribeToNetwork is a mock function for the network
func (m *MockConnection) SubscribeToNetwork(observer network.NetworkObserver) error {
	m.subscribers = append(m.subscribers, observer)
	return nil
}

// UnsubscribeFromNetwork is a mock function for the network
func (m *MockConnection) UnsubscribeFromNetwork(observer network.NetworkObserver) error {
	for i, sub := range m.subscribers {
		if sub == observer {
			m.subscribers = append(m.subscribers[:i], m.subscribers[i+1:]...)
			break
		}
	}
	return nil
}

// SendMessageToNetworkPeer is a mock function for the network
func (m *MockConnection) SendMessageToNetworkPeer(address string, message network.Message) error {
	fmt.Println("Sending message to: " + address)
	fmt.Println("Message: ", message)
	return nil
}

// SendMockNetworkMessageToSubscribers is a mock function for the network
func (m *MockConnection) SendMockNetworkMessageToSubscribers(message network.Message) error {
	for _, sub := range m.subscribers {
		sub.Notify(message)
	}
	return nil
}


__________ ./skunk/adapter/in/peer/peer.go:

package peer

import (
	"context"
	"fmt"
	"log"
	"net"
	"net/http"
	"sync"
	"time"

	"github.com/gorilla/websocket"
	"golang.org/x/net/proxy"
)

const (
	MaxConns          = 64                           // MaxConns defines the maximum number of concurrent websocket connections allowed.
	connWait          = 1 * time.Minute              // connWait specifies the timeout for connecting to another peer.
	writeWait         = 20 * time.Second             // writeWait specifies the timeout for writing to another peer. has to be high when running over tor
	shutdownWait      = 0 * time.Second              // shutdownWait specifies the wait time for shutting down the HTTP server. (optional for later)
	readRateInterval  = 2 * time.Second              // readRateInterval specifies the rate at which it will it is tried to read a message from every connection.
	readWait          = (readRateInterval * 9) / 10  // readWait specifies the time for trying to read a message from a connection. Needs to be less than readRateInterval
	heartbeatInterval = 1 * time.Minute              // heartbeatInterval specifies the time interval between consecutive heartbeat messages. when running over tor this should be high
	pongWait          = (heartbeatInterval * 9) / 10 // pongWait specifies the time a ping response can need before the connection gets classified as closed during an heartbeat. Needs to be less than heartbeatInteval
	maxMessageSize    = 512                          // maxMessageSize defines the maximum message size allowed from peer. (bytes)
)

var upgrader = websocket.Upgrader{
	ReadBufferSize:  maxMessageSize,
	WriteBufferSize: maxMessageSize,
}

// Peer encapsulates the state and functionality for a network peer, including its connections,
// configuration parameters, and synchronisation primitives for safe concurrent access.
type Peer struct {
	client     *http.Client               // client is used to make HTTP requests with a custom transport, supporting proxy configuration.
	readConns  map[string]*websocket.Conn // readConns maintains a map of active websocket connections for reading, indexed by the remote address. Note: Maybe we can later use a sync.Map
	mapRWLock  sync.RWMutex               // mapRWLock provides concurrent access control for readConns map.
	writeConn  *websocket.Conn            // writeConn is a dedicated websocket connection reserved for writing messages.
	readMutex  sync.Mutex                 // readMutex provides concurrent access control for ReadMessage.
	writeMutex sync.Mutex                 // writeMutex provides concurrent access control for WriteMessage.
	quitch     chan struct{}              // quitch is used to signal the shutdown process for the peer.
	Hostname   string                     // Hostname specifies the network address of the peer.
	Port       string                     // Port on which the peer listens for incoming connections.
	Address    string                     // Address specifies the complete websocket address: ws://Hostname:Port
	ProxyAddr  string                     // ProxyAddr specifies the address of SOCKS5 proxy, if used for connections.
}

// NewPeer initializes a new Peer instance with the given network settings.
// It also configures the peer's HTTP client for optimal proxy support.
// hostname needs to include .de, .onion...
func NewPeer(hostname string, localPort string, remotePort string, proxyAddr string) (*Peer, error) {
	if remotePort == "" {
		remotePort = localPort
	}
	transport, err := createTransport(proxyAddr) // Attempts to create an HTTP transport, optionally configured with a SOCKS5 proxy.
	if err != nil {
		return nil, fmt.Errorf("failed to create SOCKS5 dialer: %w", err)
	}

	p := Peer{
		readConns: make(map[string]*websocket.Conn),
		Hostname:  hostname,
		Port:      localPort,
		Address:   fmt.Sprintf("ws://%s:%s", hostname, remotePort),
		ProxyAddr: proxyAddr,
		quitch:    make(chan struct{}),
		client: &http.Client{
			Transport: transport,
		},
	}

	// starts the heartbeat mechanism
	p.startHeartbeat()

	return &p, nil
}

// createTransport configures and returns an HTTP transport mechanism.
// If a proxy address is provided, it configures the transport to use a SOCKS5 proxy.
func createTransport(proxyAddr string) (*http.Transport, error) {
	if proxyAddr != "" {
		dialer, err := proxy.SOCKS5("tcp", proxyAddr, nil, nil)
		if err != nil {
			return nil, err
		}
		return &http.Transport{
			Dial: dialer.Dial,
		}, nil
	}
	return &http.Transport{}, nil
}

// Listen sets up an HTTP server and starts listening on the configured port for incoming websocket connections.
// It also starts a goroutine for graceful shutdown handling upon receiving a signal on the quitch channel.
// Optionally it uses the listener provided by tor.
func (p *Peer) Listen(l net.Listener) {
	select {
	case _, ok := <-p.quitch:
		if !ok {
			p.quitch = make(chan struct{}) // if closed, then reopen channel
		}
	default:
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/", p.handler) // Registers the main handler.

	srv := &http.Server{
		Handler: mux,
	}

	go func() {
		var err error
		if l != nil {
			// Use the provided listener
			err = srv.Serve(l)
		} else {
			// Listen on the specified port if no listener is provided
			srv.Addr = ":" + p.Port
			err = srv.ListenAndServe()
		}
		if err != http.ErrServerClosed {
			log.Printf("HTTP server listen failed: %v", err)
		}
	}()

	// Shuts down server when quitch gets closed
	go func() {
		select {
		case <-p.quitch:
			shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)

			if err := srv.Shutdown(shutdownCtx); err != nil {
				log.Printf("HTTP server shutdown failed: %v", err)
			}
			defer cancel()
		}
	}()
}

// SetWriteConn designates a specific websocket connection, identified by its address, as the sole connection for sending messages.
// It verifies that the peer is currently connected to the specified address before setting the connection.
func (p *Peer) SetWriteConn(address string) error {
	if len(p.readConns) == 0 {
		return fmt.Errorf("peer is not connected to any address")
	}

	if !p.isConnectedTo(address) {
		return fmt.Errorf("peer is not connected to address: %s", address)
	}

	p.mapRWLock.RLock()
	p.writeConn = p.readConns[address]
	p.mapRWLock.RUnlock()
	return nil
}

// Connect establishes a new websocket connection to the specified address and adds it to the pool of read connections.
// It performs connection setup with a timeout and utilizes the configured HTTP client for the connection attempt.
func (p *Peer) Connect(address string) error {
	if address == "" {
		return fmt.Errorf("empty address is not a valid address")
	}

	if address == p.Address {
		return fmt.Errorf("can't connect to own address: %s", p.Address)
	}

	if p.isConnectedTo(address) {
		return fmt.Errorf("peer is already connected to address: %s", address)
	}

	dialer := websocket.Dialer{
		HandshakeTimeout: connWait,
	}

	if p.client.Transport != nil {
		if transport, ok := p.client.Transport.(*http.Transport); ok {
			dialer.NetDial = transport.Dial
		}
	}

	// Set peer address as header so that the other peer knows at which port we are listening
	headers := http.Header{}
	headers.Add("X-Peer-Address", p.Address)

	c, _, err := dialer.Dial(address, headers)

	if err != nil {
		return fmt.Errorf("failed to dial websocket: %v", err)
	}

	return p.handleNewConnection(c, address)
}

// ReadMessage attempts to read a single message from the specified websocket connection.
// It locks the readMutex to ensure exclusive access to the connection during the read operation.
func (p *Peer) readMessage(conn *websocket.Conn, address string) (string, error) {
	if conn == nil {
		return "", fmt.Errorf("invalid connection: connection is nil")
	}

	conn.SetReadLimit(maxMessageSize)
	conn.SetReadDeadline(time.Now().Add(readWait))
	p.readMutex.Lock()
	_, messageBytes, err := conn.ReadMessage()
	p.readMutex.Unlock()
	if err != nil {
		if p.checkConnIsClosed(address, err) {
			return "", err
		} else {
			return "", nil
		}
	}

	return string(messageBytes), nil
}

// ReadMessages starts readMessage for every conn in readConns in the readRate interval.
func (p *Peer) ReadMessages(messageCh chan<- string, errorCh chan<- error) {
	ticker := time.NewTicker(readRateInterval)
	go func() {
		for {
			select {
			case <-ticker.C:
				p.mapRWLock.RLock()
				for addr, conn := range p.readConns {
					go func() {
						msg, err := p.readMessage(conn, addr)
						if err != nil {
							errorCh <- err
						} else if msg != "" { // "" can happen when an error occurs when reading from
							// the connection but the error is not due to the
							// connection being closed.
							messageCh <- msg
						}
					}()
				}
				p.mapRWLock.RUnlock()
			case <-p.quitch:
				ticker.Stop()
				return
			}
		}
	}()
}

// WriteMessage sends a message using the designated write connection.
// It locks the writeMutex to ensure exclusive access to the connection during the write operation.
func (p *Peer) WriteMessage(message string) error {
	if p.writeConn == nil {
		return fmt.Errorf("no write connection is set")
	}

	// Append From p.Address: to message so that the other peers knows which peer sent him the message.
	fullMessage := fmt.Sprintf("From %s: %s", p.Address, message)

	p.writeConn.SetWriteDeadline(time.Now().Add(writeWait))
	p.writeMutex.Lock()
	err := p.writeConn.WriteMessage(websocket.TextMessage, []byte(fullMessage))
	p.writeMutex.Unlock()
	if err != nil {
		p.checkConnIsClosed(p.writeConn.RemoteAddr().String(), err)
		return err
	}

	return nil
}

// Shutdown initiates the shutdown process for the peer, closing all active websocket connections.
// and signaling the quitch channel to stop the HTTP server.
func (p *Peer) Shutdown() {
	p.mapRWLock.RLock()
	defer p.mapRWLock.RUnlock()

	for _, conn := range p.readConns {
		conn.Close()
	}
	p.readConns = make(map[string]*websocket.Conn) // Resets the connection pool.
	p.writeConn = nil

	close(p.quitch) // Signals the shutdown listener to initiate server shutdown.
}

// handler is the HTTP request handler for upgrading incoming requests to websocket connections.
// It accepts a websocket connection and adds it to the pool of read connections.
func (p *Peer) handler(w http.ResponseWriter, r *http.Request) {
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Printf("failed to upgrade incoming connection: %v", err)
		return
	}

	if err := p.handleNewConnection(conn, r.Header.Get("X-Peer-Address")); err != nil {
		log.Printf("failed to handle new connection: %v", err)
		conn.Close() // TO-DO: Send and handle error that the peer reached its maximum of connections.
	}
}

// handleNewConnection adds a newly established websocket connection to the readConns map.
// It ensures that the total number of connections does not exceed the maximum allowed.
func (p *Peer) handleNewConnection(conn *websocket.Conn, address string) error {
	if len(p.readConns) >= MaxConns {
		return fmt.Errorf("maximum number of connections reached: %d", MaxConns)
	}

	p.mapRWLock.Lock()
	p.readConns[address] = conn
	p.mapRWLock.Unlock()
	return nil
}

// StartHearbeat initiates a periodic hearbeat mechanism for all active connections.
// It sends a ping message at regular intervals to each connection to ensure they are alive.
func (p *Peer) startHeartbeat() {
	ticker := time.NewTicker(heartbeatInterval)
	go func() {
		for {
			select {
			case <-ticker.C: // On each tick, send heartbeat to all connections.
				p.sendHeartbeatToAll()
			case <-p.quitch:
				ticker.Stop()
				return
			}
		}
	}()
}

// sendHearbeatToAll sends a hearbeat signal (ping) to each active connection.
// If a connection fails to respond to the heartbeat, it removes the connection.
func (p *Peer) sendHeartbeatToAll() {
	//p.writeMutex.Lock()
	//defer p.writeMutex.Unlock()

	// THIS IS NOT GOOD
	for address, conn := range p.readConns {
		if conn == nil {
			p.mapRWLock.Lock()
			delete(p.readConns, address)
			p.mapRWLock.Unlock()
		} else {
			conn.SetWriteDeadline(time.Now().Add(pongWait))
			if err := conn.WriteMessage(websocket.PingMessage, []byte{}); err != nil {
				p.mapRWLock.Lock()
				delete(p.readConns, address) // Optionally, we could try to reinitialize the connection here.
				p.mapRWLock.Unlock()
			}
		}
	}
}

// isConnectedTo checks if there is an existing websocket connection to the specified address.
func (p *Peer) isConnectedTo(address string) bool {
	p.mapRWLock.RLock()
	_, ok := p.readConns[address]
	p.mapRWLock.RUnlock()
	return ok
}

// checkConnIsClosed evaluates if an error during a read or write operation was due to the connection being closed.
// If so, it removes the connection from the readConns map to prevent furter use.
func (p *Peer) checkConnIsClosed(address string, err error) bool {
	if websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) {
		p.mapRWLock.Lock()
		delete(p.readConns, address)
		p.mapRWLock.Unlock()
		return true
	}
	return false
}


__________ ./skunk/adapter/in/tor/tor.go:

package tor

import (
	"context"
	"crypto/ed25519"
	"crypto/rand"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"time"

	"github.com/cretz/bine/tor"
	"github.com/ooni/go-libtor"
)

// TorConfig holds configuration parameters for a Tor instance.
type TorConfig struct {
	DataDir              string // directory for storing tor data files.
	SocksPort            string // SOCKS5 proxy port for tor connection.
	LocalPort            string // local port for incoming connections.
	RemotePort           string // remote port for hiddenservice.
	DeleteDataDirOnClose bool   // flag to delete data directory on closing tor.
	ReusePrivateKey      bool   // flag to reuse the private key across sessions.
	UseEmbedded          bool   // use the embedded tor process (go-libtor)
}

// Tor wraps a tor configuration and instance for managing tor services.
type Tor struct {
	torConfig   *TorConfig // configuration for the tor instance.
	torInstance *tor.Tor   // the tor instance.
}

// NewTor initializes a new tor instance with the provided configuration.
func NewTor(torConfig *TorConfig) (*Tor, error) {
	// basic validation of configuration paramters.
	if torConfig.SocksPort == "" {
		return nil, fmt.Errorf("no tor socks port provided")
	}
	if torConfig.SocksPort == "9050" {
		return nil, fmt.Errorf("can't use 9050 as tor socks port")
	}
	if torConfig.LocalPort == "" {
		return nil, fmt.Errorf("no local port given")
	}
	if torConfig.RemotePort == "" {
		return nil, fmt.Errorf("no remote port given")
	}
	if torConfig.LocalPort == torConfig.SocksPort || torConfig.RemotePort == torConfig.SocksPort {
		return nil, fmt.Errorf("ports for hiddenservice can't match tor socks port")
	}

	if torConfig.DataDir == "" {
		torConfig.DataDir = "tor-data"
	}

	return &Tor{
		torConfig:   torConfig,
		torInstance: nil,
	}, nil
}

// StarTor starts the tor instance with the configured settings.
func (t *Tor) StartTor() error {
	if t.torInstance != nil {
		return fmt.Errorf("can't start the same tor instance twice")
	}

	conf := &tor.StartConf{
		NoAutoSocksPort: true, // needs to be true to be able to set a custom socks port
		ExtraArgs:       []string{"--SocksPort", t.torConfig.SocksPort},
		DataDir:         t.torConfig.DataDir,
		DebugWriter:     os.Stdout, // just for testing. might change later
	}
	// if configured use the go-libtor embedded tor process creator
	if t.torConfig.UseEmbedded {
		conf.ProcessCreator = libtor.Creator
	}

	torInstance, err := tor.Start(nil, conf)
	if err != nil {
		return err
	}

	t.torInstance = torInstance
	return nil
}

// StartHiddenService starts a hidden service using the current tor instance.
func (t *Tor) StartHiddenService() (*tor.OnionService, error) {
	if t.torInstance == nil {
		return nil, fmt.Errorf("tor needs to be started before a hiddenservice can be created")
	}

	// LocalPort and RemotePort are strings because we want to provide a unified interface for the tor config
	// where you don't need to figure out which port / address has which type.
	remotePortInt, err := strconv.Atoi(t.torConfig.RemotePort)
	if err != nil {
		return nil, err
	}
	localPortInt, err := strconv.Atoi(t.torConfig.LocalPort)
	if err != nil {
		return nil, err
	}

	conf := &tor.ListenConf{
		Version3:    true, // uses v3 onion service and ed25519 key
		LocalPort:   localPortInt,
		RemotePorts: []int{remotePortInt},
	}

	// attempt to read the private key if ReusePrivateKey is true
	if t.torConfig.ReusePrivateKey {
		privateKeyPath := filepath.Join(t.torConfig.DataDir, "hidden_service_private_key")
		var privateKey ed25519.PrivateKey

		if _, err := os.Stat(privateKeyPath); err == nil {
			keyData, readErr := os.ReadFile(privateKeyPath)
			if readErr != nil {
				return nil, fmt.Errorf("failed to read private key: %v", readErr)
			}
			privateKey = ed25519.PrivateKey(keyData)
		} else {
			// generate a new private key
			_, privKey, genErr := ed25519.GenerateKey(rand.Reader)
			if genErr != nil {
				return nil, fmt.Errorf("failed to generate private key: %v", genErr)
			}
			privateKey = privKey
			// save newly generated private key
			if err := os.WriteFile(privateKeyPath, privKey.Seed(), 0600); err != nil {
				return nil, fmt.Errorf("failed to save private key: %v", err)
			}
		}
		conf.Key = privateKey
	}

	// wait at most a few minutes to publish the service
	listenCtx, listenCancel := context.WithTimeout(context.Background(), 3*time.Minute)
	defer listenCancel()

	onion, err := t.torInstance.Listen(listenCtx, conf)
	if err != nil {
		return nil, err
	}

	return onion, nil
}

// StopTor stops the tor instance (and hiddenservice) and handles cleanup.
func (t *Tor) StopTor() error {
	err := t.torInstance.Close()
	if err != nil {
		return fmt.Errorf("error stopping tor: %v", err)
	}
	t.torInstance = nil

	// clean up data directory if needed.
	if t.torConfig.DataDir != "" && t.torConfig.DeleteDataDirOnClose {
		if err := os.RemoveAll(t.torConfig.DataDir); err != nil {
			return fmt.Errorf("failed to remove data dir %v: %v", t.torConfig.DataDir, err)
		}
	}
	return nil
}


__________ ./skunk/adapter/out/frontend/mockFrontend/mockFrontendAdapter.go:

package mockFrontend

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/frontend"
	"sync"
)

var (
	mockFrontendInstance *MockFrontend
	once                 sync.Once
)

type MockFrontend struct {
	observers []frontend.FrontendObserver
}

func GetMockFrontendInstance() *MockFrontend {
	once.Do(func() {
		mockFrontendInstance = &MockFrontend{
			observers: make([]frontend.FrontendObserver, 0),
		}
	})
	return mockFrontendInstance
}

func (mf *MockFrontend) SubscribeToFrontend(observer frontend.FrontendObserver) error {
	mf.observers = append(mf.observers, observer)
	return nil
}

func (mf *MockFrontend) UnsubscribeFromFrontend(observer frontend.FrontendObserver) error {
	for i, obs := range mf.observers {
		if obs == observer {
			mf.observers = append(mf.observers[:i], mf.observers[i+1:]...)
			return nil
		}
	}
	return fmt.Errorf("observer not found")
}

func (mf *MockFrontend) SendToFrontend(message frontend.FrontendMessage) error {
	for _, observer := range mf.observers {
		err := observer.Notify(message)
		if err != nil {
			return err
		}
	}
	return nil
}

func (mf *MockFrontend) SendMockFrontendMessageToSubscribers(message frontend.FrontendMessage) error {
	return mf.SendToFrontend(message)
}


__________ ./skunk/adapter/out/storage/storageMessageQueueSQLite.go:

package storage

import (
	"database/sql"
	_ "github.com/mattn/go-sqlite3"
	"log"
)

type StoreMessageQueueSQLite struct {
}

func (s *StoreMessageQueueSQLite) StoreMessageQueue(string2 string) error {
	db, err := sql.Open("sqlite3", "./yourdatabase.db")
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	// Check for table existence and create if not exists
	createTableSQL := `CREATE TABLE IF NOT EXISTS exampleTable (
        "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,     
        "data" TEXT
    );` // SQL Statement for Create Table

	_, err = db.Exec(createTableSQL)
	if err != nil {
		log.Fatal(err)
	}
	return nil
}

func (s *StoreMessageQueueSQLite) RetriveMessageQueue() (string, error) {
	return "", nil
}


__________ ./skunk/adapter/out/storage/storageSQLiteAdapter/StorageSQLiteAdapter.go:

package storageSQLiteAdapter

import (
	"database/sql"
	"fmt"
	_ "github.com/mattn/go-sqlite3"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
	"log"
	"strings"
	"sync"
)

type StorageSQLiteAdapter struct {
	db *sql.DB
}

var (
	instance *StorageSQLiteAdapter
	once     sync.Once
)

// NewStorageSQLiteAdapter creates a new instance of StorageSQLiteAdapter and initializes the database
func newStorageSQLiteAdapter(dbPath string) *StorageSQLiteAdapter {
	db, err := sql.Open("sqlite3", dbPath)
	if err != nil {
		log.Fatal(err)
	}

	// Create tables if they don't exist
	adapter := &StorageSQLiteAdapter{db: db}
	adapter.CreateTables()

	return adapter
}

// GetInstance returns the singleton instance of StorageSQLiteAdapter
func GetInstance(dbPath string) *StorageSQLiteAdapter {
	once.Do(func() {
		instance = newStorageSQLiteAdapter(dbPath)
	})
	return instance
}

func (a *StorageSQLiteAdapter) CreateTables() {
	sqlCommands := "CREATE TABLE IF NOT EXISTS Chats (\n    chat_id VARCHAR(1024) NOT NULL CONSTRAINT Chats_pk PRIMARY KEY,\n    name VARCHAR(40) NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS Peers (\n    peer_id INTEGER NOT NULL CONSTRAINT Peers_pk PRIMARY KEY AUTOINCREMENT,\n    public_key VARCHAR(1024) NOT NULL,\n    address VARCHAR(1024) NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS ChatMembers (\n    chat_member_id INTEGER NOT NULL CONSTRAINT ChatMembers_pk PRIMARY KEY AUTOINCREMENT,\n    date INTEGER NOT NULL,\n    peer_id VARCHAR(1024) NOT NULL CONSTRAINT ChatMembers_Peers_peer_id_fk REFERENCES Peers ON UPDATE CASCADE,\n    chat_id VARCHAR(1024) NOT NULL CONSTRAINT ChatMembers_Chats_chat_id_fk REFERENCES Chats ON UPDATE CASCADE,\n    username VARCHAR(50)\n);\n\nCREATE TABLE IF NOT EXISTS Messages (\n    message_id VARCHAR(1024) NOT NULL CONSTRAINT Messages_pk PRIMARY KEY,\n    content TEXT,\n    date INTEGER NOT NULL,\n    operation INTEGER NOT NULL,\n    sender_peer_id VARCHAR(1024) NOT NULL CONSTRAINT Messages_Peers_peer_id_fk REFERENCES Peers ON UPDATE CASCADE,\n    chat_id VARCHAR(1024) NOT NULL CONSTRAINT Messages_Chats_chat_id_fk REFERENCES Chats ON UPDATE CASCADE,\n    receiver_peer_id VARCHAR(1024) NOT NULL CONSTRAINT Messages_Peers_peer_id_fk_2 REFERENCES Peers,\n    sender_address VARCHAR(1024) NOT NULL,\n    receiver_address VARCHAR(1024) NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS Invitations (\n    invitation_id INTEGER NOT NULL CONSTRAINT Invitations_pk PRIMARY KEY AUTOINCREMENT,\n    invitation_status INTEGER NOT NULL,\n    message_id VARCHAR(1024) NOT NULL CONSTRAINT Invitations_Messages_message_id_fk REFERENCES Messages\n);\n\nCREATE TABLE IF NOT EXISTS PeersInInvitedChat (\n    public_key VARCHAR(1024) NOT NULL,\n    invited_peer_id INTEGER NOT NULL CONSTRAINT PeersInInvitedChat_pk PRIMARY KEY AUTOINCREMENT,\n    address VARCHAR(1024) NOT NULL,\n    invitation_id INTEGER NOT NULL CONSTRAINT PeersInInvitedChat_Invitations_invitation_id_fk REFERENCES Invitations\n);\n"
	_, err := a.db.Exec(sqlCommands)
	if err != nil {
		log.Fatal(err)
	}
}

func (a *StorageSQLiteAdapter) ChatCreated(chatName string, chatId string) error {
	//TODO implement me
	panic("implement me")
}

func (a *StorageSQLiteAdapter) PeerSetUsername(peerId string, chatId string, username string) error {
	//TODO implement me
	panic("implement me")
}

func (a *StorageSQLiteAdapter) SetPeerUsername(username, peerID, chatID string) error {
	stmt, err := a.db.Prepare("UPDATE ChatMembers SET username = ? WHERE peer_id = ? AND chat_id = ?")
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(username, peerID, chatID)
	return err
}

func (a *StorageSQLiteAdapter) PeerJoinedChat(peerID, chatID string) error {
	stmt, err := a.db.Prepare("INSERT INTO ChatMembers (date, peer_id, chat_id) SELECT datetime('now'), ?, ? WHERE NOT EXISTS (SELECT 1 FROM ChatMembers WHERE peer_id = ? AND chat_id = ?)")
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(peerID, chatID, peerID, chatID)
	return err
}

func (a *StorageSQLiteAdapter) PeerLeftChat(peerID, chatID string) error {
	stmt, err := a.db.Prepare("DELETE FROM ChatMembers WHERE peer_id = ? AND chat_id = ?")
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(peerID, chatID)
	return err
}

func (a *StorageSQLiteAdapter) CreateChat(chatID, name string) error {
	stmt, err := a.db.Prepare("INSERT INTO Chats (chat_id, name) SELECT ?, ? WHERE NOT EXISTS (SELECT 1 FROM Chats WHERE chat_id = ?)")
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(chatID, name, chatID)
	return err
}

func (a *StorageSQLiteAdapter) InvitedToChat(messageID string, peers []store.PublicKeyAddress) error {
	tx, err := a.db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	stmt, err := tx.Prepare("INSERT INTO Invitations (invitation_status, message_id) SELECT 0, ? WHERE NOT EXISTS (SELECT 1 FROM Invitations WHERE message_id = ?)")
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(messageID, messageID)
	if err != nil {
		return err
	}

	stmt, err = tx.Prepare("INSERT INTO PeersInInvitedChat (public_key, address, invitation_id) SELECT ?, ?, (SELECT invitation_id FROM Invitations WHERE message_id = ?) WHERE NOT EXISTS (SELECT 1 FROM PeersInInvitedChat WHERE public_key = ? AND address = ? AND invitation_id = (SELECT invitation_id FROM Invitations WHERE message_id = ?))")
	if err != nil {
		return err
	}
	defer stmt.Close()

	for _, peer := range peers {
		_, err = stmt.Exec(peer.PublicKey, peer.Address, messageID, peer.PublicKey, peer.Address, messageID)
		if err != nil {
			return err
		}
	}

	err = tx.Commit()
	return err
}

func (a *StorageSQLiteAdapter) PeerGotInvitedToChat(peerId string, chatId string) error {
	// Implement the logic to store a peer getting invited to a chat in the database
	// ...
	return nil
}

func (a *StorageSQLiteAdapter) GetInvitations(peerID string) ([]string, error) {
	rows, err := a.db.Query(`
		SELECT m.*, i.invitation_status 
		FROM Messages m
		JOIN Invitations i ON i.message_id = m.message_id
		WHERE m.receiver_peer_id = ? AND m.operation = ?
	`, peerID, network.INVITE_TO_CHAT)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var invitations []string
	for rows.Next() {
		var invitation string
		err := rows.Scan(&invitation)
		if err != nil {
			return nil, err
		}
		invitations = append(invitations, invitation)
	}

	return invitations, nil
}

func (a *StorageSQLiteAdapter) GetMissingInternalMessages(chatID string, inputMessageIDs []string) ([]string, error) {
	query := "SELECT message_id FROM Messages WHERE chat_id = ? AND message_id NOT IN (?" + strings.Repeat(",?", len(inputMessageIDs)-1) + ")"
	args := make([]interface{}, len(inputMessageIDs)+1)
	args[0] = chatID
	for i, id := range inputMessageIDs {
		args[i+1] = id
	}

	rows, err := a.db.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var messages []string
	for rows.Next() {
		var message string
		err := rows.Scan(&message)
		if err != nil {
			return nil, err
		}
		messages = append(messages, message)
	}

	return messages, nil
}

func (a *StorageSQLiteAdapter) GetMissingExternalMessages(chatID string, inputMessageIDs []string) ([]string, error) {
	query := "SELECT message_id FROM Messages WHERE chat_id = ? AND message_id NOT IN (SELECT message_id FROM Messages WHERE chat_id = ? AND message_id IN (?" + strings.Repeat(",?", len(inputMessageIDs)-1) + "))"
	args := make([]interface{}, len(inputMessageIDs)+2)
	args[0] = chatID
	args[1] = chatID
	for i, id := range inputMessageIDs {
		args[i+2] = id
	}

	rows, err := a.db.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var messages []string
	for rows.Next() {
		var message string
		err := rows.Scan(&message)
		if err != nil {
			return nil, err
		}
		messages = append(messages, message)
	}

	return messages, nil
}

func (a *StorageSQLiteAdapter) StoreMessage(message network.Message) error {
	// Check if sender exists in Peers table, and insert if not
	err := a.insertPeerIfNotExists(message.SenderID, message.SenderAddress)
	if err != nil {
		return err
	}

	// Check if receiver exists in Peers table, and insert if not
	err = a.insertPeerIfNotExists(message.ReceiverID, message.ReceiverAddress)
	if err != nil {
		return err
	}

	stmt, err := a.db.Prepare(`
        INSERT INTO Messages (message_id, date, content, sender_peer_id, receiver_peer_id, sender_address, receiver_address, chat_id, operation)
        SELECT ?, ?, ?, (SELECT peer_id FROM Peers WHERE public_key = ?), (SELECT peer_id FROM Peers WHERE public_key = ?), ?, ?, ?, ?
        WHERE NOT EXISTS (SELECT 1 FROM Messages WHERE message_id = ?)
    `)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(
		message.Id, message.Timestamp, message.Content, message.SenderID, message.ReceiverID,
		message.SenderAddress, message.ReceiverAddress, message.ChatID, message.Operation, message.Id,
	)
	return err
}

func (a *StorageSQLiteAdapter) insertPeerIfNotExists(publicKey, address string) error {
	stmt, err := a.db.Prepare(`
        INSERT INTO Peers (public_key, address)
        SELECT ?, ?
        WHERE NOT EXISTS (SELECT 1 FROM Peers WHERE public_key = ?)
    `)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(publicKey, address, publicKey)
	return err
}

func (a *StorageSQLiteAdapter) RetrieveMessage(messageID string) (network.Message, error) {
	row := a.db.QueryRow(`
		SELECT m.message_id, m.date, m.content, m.operation, p.public_key, p2.public_key, m.sender_address, m.receiver_address, m.chat_id
		FROM Messages m, Peers p, Peers p2
		WHERE message_id = ? AND m.sender_peer_id = p.peer_id AND m.receiver_peer_id = p2.peer_id
	`, messageID)

	var message network.Message
	err := row.Scan(
		&message.Id, &message.Timestamp, &message.Content, &message.Operation, &message.SenderID, &message.ReceiverID,
		&message.SenderAddress, &message.ReceiverAddress, &message.ChatID,
	)
	if err != nil {
		return network.Message{}, err
	}

	return message, nil
}

func (a *StorageSQLiteAdapter) GetChats() ([]store.Chat, error) {
	rows, err := a.db.Query("SELECT chat_id, name FROM Chats")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var chats []store.Chat
	for rows.Next() {
		var chat store.Chat
		err := rows.Scan(&chat.ChatId, &chat.ChatName)
		if err != nil {
			return nil, err
		}
		chats = append(chats, chat)
	}

	return chats, nil
}

func (a *StorageSQLiteAdapter) GetUsername(peerID, chatID string) (string, error) {
	row := a.db.QueryRow("SELECT username FROM ChatMembers WHERE peer_id = ? AND chat_id = ?", peerID, chatID)

	var username string
	err := row.Scan(&username)
	if err != nil {
		return "", err
	}

	return username, nil
}

func (a *StorageSQLiteAdapter) GetUsersInChat(chatID string) ([]store.User, error) {
	rows, err := a.db.Query("SELECT peer_id, chat_id, username FROM ChatMembers WHERE chat_id = ?", chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var users []store.User
	for rows.Next() {
		var user store.User
		err := rows.Scan(&user.UserId, &user.Username)
		if err != nil {
			return nil, err
		}
		users = append(users, user)
	}

	return users, nil
}

func (a *StorageSQLiteAdapter) GetPeers() ([]string, error) {
	rows, err := a.db.Query("SELECT public_key FROM Peers")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var peers []string
	for rows.Next() {
		var peer string
		err := rows.Scan(&peer)
		if err != nil {
			return nil, err
		}
		peers = append(peers, peer)
	}

	return peers, nil
}

func (a *StorageSQLiteAdapter) GetChatMessages(chatID string) ([]network.Message, error) {
	rows, err := a.db.Query(`
		SELECT m.message_id, m.content, m.date, m.operation, p.public_key, m.chat_id, p2.public_key, m.sender_address, m.receiver_address
		FROM Messages m, Peers p, Peers p2
		WHERE chat_id = ? AND m.sender_peer_id = p.peer_id AND m.receiver_peer_id = p2.peer_id
	`, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var messages []network.Message
	for rows.Next() {
		var message network.Message
		err := rows.Scan(
			&message.Id, &message.Content, &message.Timestamp, &message.Operation, &message.SenderID, &message.ChatID, &message.ReceiverID,
			&message.SenderAddress, &message.ReceiverAddress,
		)
		if err != nil {
			return nil, err
		}
		messages = append(messages, message)
	}

	return messages, nil
}

func (a *StorageSQLiteAdapter) JoinChat(peerID, chatID string, invitationID int) error {
	// Check if the invitation exists and get the chat name
	var chatName string
	err := a.db.QueryRow("SELECT m.chat_id, c.name FROM Invitations i JOIN Messages m ON i.message_id = m.message_id JOIN Chats c ON m.chat_id = c.chat_id WHERE i.invitation_id = ? AND i.invitation_status = 0", invitationID).Scan(&chatID, &chatName)
	if err != nil {
		if err == sql.ErrNoRows {
			return fmt.Errorf("invitation not found or already accepted")
		}
		return err
	}

	// Check if the chat exists, and create it if not
	err = a.createChatIfNotExists(chatID, chatName)
	if err != nil {
		return err
	}

	// Check if the peer exists, and insert if not
	err = a.insertPeerIfNotExists(peerID, "")
	if err != nil {
		return err
	}

	// Insert the peer into the chat
	stmt, err := a.db.Prepare(`
        INSERT INTO ChatMembers (date, peer_id, chat_id)
        SELECT datetime('now'), (SELECT peer_id FROM Peers WHERE public_key = ?), ?
        WHERE NOT EXISTS (SELECT 1 FROM ChatMembers WHERE peer_id = (SELECT peer_id FROM Peers WHERE public_key = ?) AND chat_id = ?)
    `)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(peerID, chatID, peerID, chatID)
	if err != nil {
		return err
	}

	// Update the invitation status
	_, err = a.db.Exec("UPDATE Invitations SET invitation_status = 1 WHERE invitation_id = ?", invitationID)
	return err
}

func (a *StorageSQLiteAdapter) createChatIfNotExists(chatID, chatName string) error {
	stmt, err := a.db.Prepare(`
        INSERT INTO Chats (chat_id, name)
        SELECT ?, ?
        WHERE NOT EXISTS (SELECT 1 FROM Chats WHERE chat_id = ?)
    `)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(chatID, chatName, chatID)
	return err
}


__________ ./skunk/application/domain/chat/chatLogicInterface.go:

package chat

type ChatLogic interface {
	ReceiveMessage(senderId string, chatId string, message string) error
	ReceiveChatInvitation(senderId string, chatId string, chatName string, chatMembers []string) error
	PeerLeavesChat(senderId string, chatId string) error
	PeerJoinsChat(senderId string, chatId string) error
	ReceiveFile(senderId string, chatId string, filePath string) error
	PeerSetsUsername(senderId string, chatId string, username string) error
}


__________ ./skunk/application/domain/chat/c_model/chat.go:

package c_model

type Chat struct {
	chatId string
}


__________ ./skunk/application/domain/chat/c_model/user.go:

package c_model

type User struct {
	UserId   string
	Username string
}


__________ ./skunk/application/domain/chat/c_service/chatApp.go:

package c_service

import (
	"github.com/scherzma/Skunk/cmd/skunk/application/port/frontend"
	"sync"
)

type ChatApp struct {
	frontends []frontend.Frontend
}

var (
	chatService *ChatApp
	once        sync.Once
)

func GetChatServiceInstance() *ChatApp {
	once.Do(func() {
		chatService = &ChatApp{
			frontends: []frontend.Frontend{},
		}
	})

	return chatService
}

// FrontendObserver: Gets notified when a frontend sends a message to the chat
func (c *ChatApp) Notify(message frontend.FrontendMessage) error {
	// TODO: Implement
	return nil
}

func (c *ChatApp) AddFrontend(frontend frontend.Frontend) {
	c.frontends = append(c.frontends, frontend)
}

func (c *ChatApp) RemoveFrontend(frontend frontend.Frontend) {
	for i, f := range c.frontends {
		if f == frontend {
			c.frontends = append(c.frontends[:i], c.frontends[i+1:]...)
			return
		}
	}
}

func (c *ChatApp) SendMessageToAllFrontends(message frontend.FrontendMessage) {
	for _, f := range c.frontends {
		f.SendToFrontend(message)
	}
}

func (c *ChatApp) ProcessMessageForUser(message frontend.FrontendMessage) error {
	// TODO: Implement
	return nil
}


__________ ./skunk/application/domain/p2p_network/networkLogicInterface.go:

package p2p_network

type NetworkLogic interface {
	CreateChat(chatId string, chatName string) error
	JoinChat(chatId string) error
	LeaveChat(chatId string) error
	InviteToChat(chatId string, peerId string) error
	SendFileToChat(chatId string, filePath string) error
	SetUsernameInChat(chatId string, username string) error
	SendMessageToChat(chatId string, message string) error
}


__________ ./skunk/application/domain/p2p_network/p_model/networkChatMessageRepository.go:

package p_model

import (
	"errors"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

type NetworkChatMessages struct {
	chatName        string
	chatMessagesMap map[string]network.Message
}

func NewNetworkChatMessages() *NetworkChatMessages {
	return &NetworkChatMessages{
		chatMessagesMap: make(map[string]network.Message),
	}
}

func (ncm *NetworkChatMessages) AddMessage(message network.Message) error {
	if _, exists := ncm.chatMessagesMap[message.Id]; exists {
		return errors.New("message already exists")
	}

	ncm.chatMessagesMap[message.Id] = message
	return nil
}

func (ncm *NetworkChatMessages) GetMessages() []network.Message {
	messages := make([]network.Message, 0, len(ncm.chatMessagesMap))
	for _, message := range ncm.chatMessagesMap {
		messages = append(messages, message)
	}
	return messages
}

func (ncm *NetworkChatMessages) GetMissingExternalMessages(inputMessageIDs []string) []network.Message {
	missingMessages := make([]network.Message, 0)
	inputMap := make(map[string]bool)

	// Convert input slice to map for efficient lookup
	for _, id := range inputMessageIDs {
		inputMap[id] = true
	}

	for _, message := range ncm.chatMessagesMap {
		if !inputMap[message.Id] {
			missingMessages = append(missingMessages, message)
		}
	}
	return missingMessages
}

func (ncm *NetworkChatMessages) GetMissingInternalMessages(inputMessageIDs []string) []network.Message {
	missingMessages := make([]network.Message, 0)
	ncmMap := ncm.chatMessagesMap

	for _, id := range inputMessageIDs {
		if message, exists := ncmMap[id]; !exists {
			missingMessages = append(missingMessages, message)
		}
	}
	return missingMessages
}

func (ncm *NetworkChatMessages) GetMissingInternalMessageIDs(inputMessageIDs []string) []string {
	missingMessageIDs := make([]string, 0)
	ncmMap := ncm.chatMessagesMap

	for _, id := range inputMessageIDs {
		if _, exists := ncmMap[id]; !exists {
			missingMessageIDs = append(missingMessageIDs, id)
		}
	}
	return missingMessageIDs
}

func (ncm *NetworkChatMessages) GetUsername() string {
	return "todo: implement me (Username)" // TODO implement me
}

func (ncm *NetworkChatMessages) GetChatName() string {
	return ncm.chatName
}

func (ncm *NetworkChatMessages) SetChatName(chatName string) {
	ncm.chatName = chatName
}


__________ ./skunk/application/domain/p2p_network/p_model/networkChatRepository.go:

package p_model

type NetworkChats struct {
	chatMap map[string]NetworkChatMessages
}

var instance *NetworkChats

func GetNetworkChatsInstance() *NetworkChats {
	if instance == nil {
		instance = &NetworkChats{
			chatMap: make(map[string]NetworkChatMessages),
		}
	}
	return instance
}

func (n *NetworkChats) AddChat(chatId string) {
	if _, ok := n.chatMap[chatId]; ok {
		return
	}
	n.chatMap[chatId] = *NewNetworkChatMessages()
}

func (n *NetworkChats) GetChat(chatId string) NetworkChatMessages {
	if _, exists := n.chatMap[chatId]; !exists { //TODO change default behavior; probably should not create a new chat if it does not exist
		n.AddChat(chatId)
	}
	return n.chatMap[chatId]
}


__________ ./skunk/application/domain/p2p_network/p_service/securityService.go:

package p_service

import (
	"encoding/json"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
)

type SecurityValidater interface {
	ValidateOutgoingMessage(message network.Message) bool
	ValidateIncomingMessage(message network.Message) bool
	ValidatePeer(peer string) bool
}

// SecurityContext is a service that provides security checks for the network
// It should be possible to implement all security checks in this service
// TODO: put a bit more thought into this
type SecurityContext struct {
	store           store.ChatInvitationStoragePort
	chatActionStore store.ChatActionStoragePort
	displayStorage  store.DisplayStoragePort
}

func NewSecurityContext(displayStorage store.DisplayStoragePort, store store.ChatInvitationStoragePort, chatActionStore store.ChatActionStoragePort) *SecurityContext {
	return &SecurityContext{
		store:           store,
		chatActionStore: chatActionStore,
		displayStorage:  displayStorage,
	}
}

func (s *SecurityContext) ValidateOutgoingMessage(message network.Message) bool {
	return true
}

func (s *SecurityContext) ValidateIncomingMessage(message network.Message) bool {
	switch message.Operation {
	case network.SEND_MESSAGE:
		return s.isMemberOfChat(message.SenderID, message.ChatID)
	case network.SYNC_REQUEST:
		return s.isMemberOfChat(message.SenderID, message.ChatID)
	case network.SYNC_RESPONSE:
		return s.validateSyncResponseMessages(message)
	case network.JOIN_CHAT:
		return s.hasValidInvitation(message.SenderID, message.ChatID)
	case network.LEAVE_CHAT:
		return s.isMemberOfChat(message.SenderID, message.ChatID)
	case network.INVITE_TO_CHAT:
		return true
	case network.SEND_FILE:
		return s.isMemberOfChat(message.SenderID, message.ChatID)
	case network.SET_USERNAME:
		return s.isMemberOfChat(message.SenderID, message.ChatID)
	default:
		return false
	}
}

func (s *SecurityContext) ValidatePeer(peer string) bool {
	return true
}

// Helper methods for security checks
func (s *SecurityContext) isMemberOfChat(peerID, chatID string) bool {
	members, err := s.displayStorage.GetUsersInChat(chatID)
	if err != nil {
		return false
	}

	for _, member := range members {
		if member.UserId == peerID {
			return true
		}
	}

	return false
}

func (s *SecurityContext) hasValidInvitation(peerID, chatID string) bool {
	invitations, err := s.store.GetInvitations(peerID)
	if err != nil {
		return false
	}

	for _, invitation := range invitations {
		if invitation == chatID {
			return true
		}
	}

	return false
}

func (s *SecurityContext) validateSyncResponseMessages(message network.Message) bool {
	var receivedMessages []network.Message
	err := json.Unmarshal([]byte(message.Content), &receivedMessages)
	if err != nil {
		return false
	}

	for _, msg := range receivedMessages {
		if msg.SenderID != message.SenderID {
			return false
		}
	}

	return true
}


__________ ./skunk/application/domain/p2p_network/p_service/peer.go:

package p_service

import (
	"errors"
	"github.com/scherzma/Skunk/cmd/skunk/adapter/out/storage/storageSQLiteAdapter"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
	"sync"
)

var (
	peerInstance *Peer
	once         sync.Once
)

type Peer struct {
	handlers        map[network.OperationType]messageHandlers.MessageHandler
	connections     []network.NetworkConnection
	securityContext SecurityValidater
	storage         store.NetworkMessageStoragePort
	messageSender   messageHandlers.MessageSender
}

func GetPeerInstance() *Peer {
	once.Do(func() {
		storage := storageSQLiteAdapter.GetInstance("skunk.db")
		securityContext := NewSecurityContext(storage, storage, storage)
		sender := messageHandlers.NewMessageSender(securityContext)

		handlers := map[network.OperationType]messageHandlers.MessageHandler{
			network.JOIN_CHAT:      messageHandlers.NewJoinChatHandler(nil, storage),
			network.SEND_FILE:      messageHandlers.NewSendFileHandler(nil, storage),
			network.SYNC_REQUEST:   messageHandlers.NewSyncRequestHandler(nil, storage),
			network.SYNC_RESPONSE:  messageHandlers.NewSyncResponseHandler(storage),
			network.SET_USERNAME:   messageHandlers.NewSetUsernameHandler(nil, storage),
			network.SEND_MESSAGE:   messageHandlers.NewSendMessageHandler(nil, storage),
			network.INVITE_TO_CHAT: messageHandlers.NewInviteToChatHandler(nil, storage),
			network.LEAVE_CHAT:     messageHandlers.NewLeaveChatHandler(nil, storage),
			network.TEST_MESSAGE:   &messageHandlers.TestMessageHandler{},
			network.TEST_MESSAGE_2: &messageHandlers.TestMessageHandler2{},
		}

		peerInstance = &Peer{
			handlers:        handlers,
			connections:     []network.NetworkConnection{},
			securityContext: securityContext,
			storage:         storage,
			messageSender:   *sender,
		}
	})

	return peerInstance
}

func (p *Peer) AddNetworkConnection(connection network.NetworkConnection) error {
	if len(p.connections) > 0 {
		return errors.New("connection already exists, multiple connections are not supported so far")
	}

	p.connections = append(p.connections, connection)
	connection.SubscribeToNetwork(p)
	p.messageSender.SetNetworkConnection(connection)

	return nil
}

func (p *Peer) RemoveNetworkConnection(connection network.NetworkConnection) {
	for i, c := range p.connections {
		if c == connection {
			p.connections = append(p.connections[:i], p.connections[i+1:]...)
			connection.UnsubscribeFromNetwork(p)
			break
		}
	}
}

func (p *Peer) Notify(message network.Message) error {
	if handler, exists := p.handlers[message.Operation]; exists {
		if !p.securityContext.ValidateIncomingMessage(message) {
			return errors.New("invalid message")
		}

		p.storage.StoreMessage(message)
		return handler.HandleMessage(message)
	}
	return errors.New("invalid message operation")
}


__________ ./skunk/application/domain/p2p_network/p_service/chatToNetwork.go:

package p_service

import (
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
)

type ChatToNetwork struct {
	sender            *messageHandlers.MessageSender
	chatActionStorage *store.ChatActionStoragePort
}

func (c *ChatToNetwork) CreateChat(chatId string, chatName string) error {
	err := c.chatActionStorage.ChatCreated(chatName, chatId)
	if err != nil {
		return err
	}
	return nil
}

func (c *ChatToNetwork) JoinChat(chatId string) error {
	return nil
}

func (c *ChatToNetwork) LeaveChat(chatId string) error {
	return nil
}

func (c *ChatToNetwork) InviteToChat(chatId string, peerId string) error {
	return nil
}

func (c *ChatToNetwork) SendFileToChat(chatId string, filePath string) error {
	return nil
}

func (c *ChatToNetwork) SetUsernameInChat(chatId string, username string) error {
	return nil
}

func (c *ChatToNetwork) SendMessageToChat(chatId string, message string) error {
	return nil
}


__________ ./skunk/application/domain/p2p_network/p_service/messageHandlers/inviteToChatHandler.go:

package messageHandlers

import (
	"encoding/json"
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/chat"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
)

// InviteToChatHandler handles invitations for a peer to join a chat
type InviteToChatHandler struct {
	userChatLogic         chat.ChatLogic
	chatInvitationStorage store.ChatInvitationStoragePort
}

// NewInviteToChatHandler creates a new InviteToChatHandler
func NewInviteToChatHandler(userChatLogic chat.ChatLogic, chatInvitationStorage store.ChatInvitationStoragePort) *InviteToChatHandler {
	return &InviteToChatHandler{
		userChatLogic:         userChatLogic,
		chatInvitationStorage: chatInvitationStorage,
	}
}

// HandleMessage processes the chat invitation message
func (i *InviteToChatHandler) HandleMessage(message network.Message) error {

	// Message structure:
	/*
		{
			"chatId": "chat_id",
			"chatName": "chat_name",
			"peers": [
				{
					"address": "peer_address",
					"publicKey": "peer_public_key"
				},
				...
			]
		}
	*/

	var content struct {
		ChatID   string                   `json:"chatId"`
		ChatName string                   `json:"chatName"`
		Peers    []store.PublicKeyAddress `json:"peers"`
	}

	err := json.Unmarshal([]byte(message.Content), &content)
	if err != nil {
		fmt.Println("Error unmarshalling message content")
		return err
	}

	// Store the chat invitation details
	err = i.chatInvitationStorage.InvitedToChat(message.Id, content.Peers)
	if err != nil {
		return err
	}

	// Extract addresses from peers
	peerAddresses := make([]string, len(content.Peers))
	for idx, peer := range content.Peers {
		peerAddresses[idx] = peer.Address
	}

	// Notify the chat logic of the received invitation
	i.userChatLogic.ReceiveChatInvitation(message.SenderID, content.ChatID, content.ChatName, peerAddresses)

	return nil
}


__________ ./skunk/application/domain/p2p_network/p_service/messageHandlers/joinChatHandler.go:

package messageHandlers

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/chat"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
)

// A Peer joins a chat
type joinChatHandler struct {
	userChatLogic     chat.ChatLogic
	chatActionStorage store.ChatActionStoragePort
}

func NewJoinChatHandler(userChatLogic chat.ChatLogic, chatActionStorage store.ChatActionStoragePort) *joinChatHandler {
	return &joinChatHandler{
		userChatLogic:     userChatLogic,
		chatActionStorage: chatActionStorage,
	}
}

func (j *joinChatHandler) HandleMessage(message network.Message) error {

	// Update chat invitation storage
	err := j.chatActionStorage.PeerJoinedChat(message.SenderID, message.ChatID)
	if err != nil {
		fmt.Println("Error updating chat invitation storage")
		return err
	}

	// Handle peer joining the chat
	j.userChatLogic.PeerJoinsChat(message.SenderID, message.ChatID)

	return nil
}


__________ ./skunk/application/domain/p2p_network/p_service/messageHandlers/leaveChatHandler.go:

package messageHandlers

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/chat"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
)

// A Peer leaves a chat
type leaveChatHandler struct {
	userChatLogic     chat.ChatLogic
	chatActionStorage store.ChatActionStoragePort
}

func NewLeaveChatHandler(userChatLogic chat.ChatLogic, chatActionStorage store.ChatActionStoragePort) *leaveChatHandler {
	return &leaveChatHandler{
		userChatLogic:     userChatLogic,
		chatActionStorage: chatActionStorage,
	}
}

func (l *leaveChatHandler) HandleMessage(message network.Message) error {

	// Update chat invitation storage and remove the peer from the chat
	err := l.chatActionStorage.PeerLeftChat(message.SenderID, message.ChatID)
	if err != nil {
		fmt.Println("Error updating chat invitation storage")
		return err
	}

	// Handle peer leaving the chat
	l.userChatLogic.PeerLeavesChat(message.SenderID, message.ChatID)

	return nil
}


__________ ./skunk/application/domain/p2p_network/p_service/messageHandlers/messageHandlerInterface.go:

package messageHandlers

import "github.com/scherzma/Skunk/cmd/skunk/application/port/network"

type MessageHandler interface {
	HandleMessage(message network.Message) error
}


__________ ./skunk/application/domain/p2p_network/p_service/messageHandlers/sendFileHandler.go:

package messageHandlers

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/chat"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
	"io"
	"os"
	"path/filepath"
)

// A Peer sends a file to a chat
type sendFileHandler struct {
	userChatLogic         chat.ChatLogic
	chatInvitationStorage store.ChatInvitationStoragePort
}

func NewSendFileHandler(userChatLogic chat.ChatLogic, chatInvitationStorage store.ChatInvitationStoragePort) *sendFileHandler {
	return &sendFileHandler{
		userChatLogic:         userChatLogic,
		chatInvitationStorage: chatInvitationStorage,
	}
}

func (s *sendFileHandler) HandleMessage(message network.Message) error {

	// Structure of the message (fileContent is base64 encoded):
	/*
		{
			"fileName": "file_name",
			"fileExtension": "file_extension",
			"fileContent": "YmFzZTY0c3RyaW5n",
		}
	*/

	var content struct {
		FileName      string `json:"fileName"`
		FileExtension string `json:"fileExtension"`
		FileContent   string `json:"fileContent"`
	}

	err := json.Unmarshal([]byte(message.Content), &content)
	if err != nil {
		fmt.Println("Error unmarshalling message content")
		return err
	}

	// Decode the base64-encoded file content
	fileData, err := base64.StdEncoding.DecodeString(content.FileContent)
	if err != nil {
		fmt.Println("Error decoding file content")
		return err
	}

	// Create a directory for storing the files if it doesn't exist
	fileDir := "./stored_files"
	if err := os.MkdirAll(fileDir, os.ModePerm); err != nil {
		fmt.Println("Error creating file directory")
		return err
	}

	// Create the file path
	filePath := filepath.Join(fileDir, fmt.Sprintf("%s.%s", content.FileName, content.FileExtension))

	// Check if the file already exists
	if _, err := os.Stat(filePath); err == nil {
		// File exists, compare hashes
		existingHash, err := computeFileHash(filePath)
		if err != nil {
			fmt.Println("Error computing hash of existing file")
			return err
		}

		newFileHash := computeHash(fileData)
		if existingHash == newFileHash {
			// Hashes are the same, use the existing file
			s.userChatLogic.ReceiveFile(message.SenderID, message.ChatID, filePath)
			return nil
		} else {
			// Hashes are different, modify the file name
			filePath = getUniqueFilePath(fileDir, content.FileName, content.FileExtension)
		}
	}

	// Write the file data to the file
	if err := os.WriteFile(filePath, fileData, os.ModePerm); err != nil {
		fmt.Println("Error writing file to filesystem")
		return err
	}

	// Notify the chat logic of the received file with the file path
	s.userChatLogic.ReceiveFile(message.SenderID, message.ChatID, filePath)

	return nil
}

// computeFileHash computes the SHA-256 hash of a file
func computeFileHash(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hash := sha256.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}

	return hex.EncodeToString(hash.Sum(nil)), nil
}

// computeHash computes the SHA-256 hash of the given data
func computeHash(data []byte) string {
	hash := sha256.New()
	hash.Write(data)
	return hex.EncodeToString(hash.Sum(nil))
}

// getUniqueFilePath generates a unique file path by appending a counter to the file name
func getUniqueFilePath(dir, baseName, ext string) string {
	counter := 1
	for {
		newFileName := fmt.Sprintf("%s_%d.%s", baseName, counter, ext)
		newFilePath := filepath.Join(dir, newFileName)
		if _, err := os.Stat(newFilePath); os.IsNotExist(err) {
			return newFilePath
		}
		counter++
	}
}


__________ ./skunk/application/domain/p2p_network/p_service/messageHandlers/sendMessageHandler.go:

package messageHandlers

import (
	"encoding/json"
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/chat"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
)

type sendMessageHandler struct {
	userChatLogic         chat.ChatLogic
	networkMessageStorage store.NetworkMessageStoragePort
}

func NewSendMessageHandler(userChatLogic chat.ChatLogic, networkMessageStorage store.NetworkMessageStoragePort) *sendMessageHandler {
	return &sendMessageHandler{
		userChatLogic:         userChatLogic,
		networkMessageStorage: networkMessageStorage,
	}
}

func (s *sendMessageHandler) HandleMessage(message network.Message) error {

	// Structure of the message:
	/*
		{
			"message": "asdfasdfasdf",
		}
	*/

	var content struct {
		Message string `json:"message"`
	}

	err := json.Unmarshal([]byte(message.Content), &content)
	if err != nil {
		fmt.Println("Error unmarshalling message content")
		return err
	}

	// Store the message
	err = s.networkMessageStorage.StoreMessage(message)
	if err != nil {
		fmt.Println("Error storing message")
		return err
	}

	// Handle the received message
	s.userChatLogic.ReceiveMessage(message.SenderID, message.ChatID, content.Message)

	return nil
}


__________ ./skunk/application/domain/p2p_network/p_service/messageHandlers/setUsernameHandler.go:

package messageHandlers

import (
	"encoding/json"
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/chat"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
)

type setUsernameHandler struct {
	userChatLogic      chat.ChatLogic
	userMessageStorage store.UserMessageStoragePort
}

func NewSetUsernameHandler(userChatLogic chat.ChatLogic, userMessageStorage store.UserMessageStoragePort) *setUsernameHandler {
	return &setUsernameHandler{
		userChatLogic:      userChatLogic,
		userMessageStorage: userMessageStorage,
	}
}

func (s *setUsernameHandler) HandleMessage(message network.Message) error {

	// Structure of the message:
	/*
		{
			"username": "asdfasdfasdf",
		}
	*/

	var content struct {
		Username string `json:"username"`
	}

	err := json.Unmarshal([]byte(message.Content), &content)
	if err != nil {
		fmt.Println("Error unmarshalling message content")
		return err
	}

	// Store the username
	err = s.userMessageStorage.PeerSetUsername(message.SenderID, message.ChatID, content.Username)
	if err != nil {
		fmt.Println("Error storing username")
		return err
	}

	// Handle the username change
	s.userChatLogic.PeerSetsUsername(message.SenderID, message.ChatID, content.Username)

	return nil
}


__________ ./skunk/application/domain/p2p_network/p_service/messageHandlers/syncRequestHandler.go:

package messageHandlers

import (
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/p2p_network/p_model"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
	"time"
)

type syncRequestHandler struct {
	syncStorage           store.SyncStoragePort
	networkMessageStorage store.NetworkMessageStoragePort
	messageSender         MessageSender
}

func NewSyncRequestHandler(syncStorage store.SyncStoragePort, networkMessageStorage store.NetworkMessageStoragePort) *syncRequestHandler {
	return &syncRequestHandler{
		syncStorage:           syncStorage,
		networkMessageStorage: networkMessageStorage,
	}
}

func (s *syncRequestHandler) HandleMessage(message network.Message) error {

	chatRepo := p_model.GetNetworkChatsInstance()       // TODO: change
	chatMessageRepo := chatRepo.GetChat(message.ChatID) // TODO: change

	// Parse the content of the message
	/*
		{
		  "existingMessageIds": [
			"<message id 1>",
			"<message id 2>",
			...
		  ]
		}
	*/

	var content struct {
		ExistingMessageIDs []string `json:"existingMessageIds"`
	}
	err := json.Unmarshal([]byte(message.Content), &content)
	if err != nil {
		fmt.Println("Error unmarshalling message content")
		return err
	}

	// Find difference between "message" already known messages and own messages that the other peer does not know
	missingExternalMessages := chatMessageRepo.GetMissingExternalMessages(content.ExistingMessageIDs)   // TODO: change
	missingInternalMessages := chatMessageRepo.GetMissingInternalMessageIDs(content.ExistingMessageIDs) // TODO: change

	// Convert missingExternalMessages to a JSON string
	externalMessagesBytes, err := json.Marshal(missingExternalMessages)
	if err != nil {
		fmt.Println("Error marshalling missing external messages")
		return err
	}

	// Convert missingInternalMessages to a JSON string
	internalMessagesBytes, err := json.Marshal(missingInternalMessages)
	if err != nil {
		fmt.Println("Error marshalling missing internal messages")
		return err
	}

	// Send the sync response to the other peer
	syncResponse := network.Message{
		Id:              uuid.New().String(),
		Timestamp:       time.Now().UnixNano(),
		Content:         string(externalMessagesBytes),
		SenderID:        chatMessageRepo.GetUsername(), // TODO: change
		ReceiverID:      message.SenderID,              // TODO: change
		SenderAddress:   message.SenderAddress,         // TODO: change
		ReceiverAddress: message.ReceiverAddress,       // TODO: change
		ChatID:          message.ChatID,
		Operation:       network.SYNC_RESPONSE,
	}

	// Send sync request to other peer to get the difference between the messages that the other peer knows this peer does not know
	syncRequest := network.Message{
		Id:              uuid.New().String(),
		Timestamp:       time.Now().UnixNano(),
		Content:         string(internalMessagesBytes),
		SenderID:        chatMessageRepo.GetUsername(),
		ReceiverID:      message.ReceiverID,
		SenderAddress:   message.SenderAddress,
		ReceiverAddress: message.ReceiverAddress,
		ChatID:          message.ChatID,
		Operation:       network.SYNC_REQUEST,
	}

	s.messageSender.SendMessage("addressResponse", syncResponse)
	s.messageSender.SendMessage("addressRequest", syncRequest)

	return nil
}


__________ ./skunk/application/domain/p2p_network/p_service/messageHandlers/syncResponseHandler.go:

package messageHandlers

import (
	"encoding/json"
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
)

type syncResponseHandler struct {
	networkMessageStorage store.NetworkMessageStoragePort
}

func NewSyncResponseHandler(networkMessageStorage store.NetworkMessageStoragePort) *syncResponseHandler {
	return &syncResponseHandler{
		networkMessageStorage: networkMessageStorage,
	}
}

func (s *syncResponseHandler) HandleMessage(message network.Message) error {
	//chatRepo := p_model.GetNetworkChatsInstance() TODO: change
	//chatMessageRepo := chatRepo.GetChat(message.ChatID) TODO: change

	var receivedMessages []network.Message
	err := json.Unmarshal([]byte(message.Content), &receivedMessages)
	if err != nil {
		fmt.Println("Error unmarshalling message content")
		return err
	}

	for _, msg := range receivedMessages {
		// Store the message
		err = s.networkMessageStorage.StoreMessage(msg)
		if err != nil {
			fmt.Println("Error storing message:", err)
			return err
		}
		// Add the message to the chat repository
		//chatMessageRepo.AddMessage(msg) TODO: change
	}

	return nil
}


__________ ./skunk/application/domain/p2p_network/p_service/messageHandlers/testMessage2Handler.go:

package messageHandlers

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

type TestMessageHandler2 struct {
}

func (t *TestMessageHandler2) HandleMessage(message network.Message) error {
	fmt.Println("TestMessageHandler_2: ", message.Content)
	return nil
}


__________ ./skunk/application/domain/p2p_network/p_service/messageHandlers/testMessageHandler.go:

package messageHandlers

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

type TestMessageHandler struct {
}

func (t *TestMessageHandler) HandleMessage(message network.Message) error {

	fmt.Println("TestMessageHandler: ", message.Content)
	return nil
}


__________ ./skunk/application/domain/p2p_network/p_service/messageHandlers/messageSender.go:

package messageHandlers

import (
	"errors"
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/p2p_network/p_service"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

// This has many problems right now.
// For example is it only able to handle on connection. That means, while the peer is able to handle more, this is a bottleneck.
// One could create multiple MessageSenders, but this is probably a bad idea.
// Because, if done so, everything would need multiple messageSenders, or swap them for possibly ever message.
// Still, being able to handle multiple networkConnections is not a requirement for the first release, and while many parts of the architecture support it, this will suffice.

type MessageSender struct {
	networkConnection network.NetworkConnection
	securityContext   p_service.SecurityValidater
}

func NewMessageSender(securityContext p_service.SecurityValidater) *MessageSender {
	return &MessageSender{
		securityContext:   securityContext,
		networkConnection: nil,
	}
}

func (m *MessageSender) SendMessage(address string, message network.Message) error {
	if m.networkConnection == nil {
		return fmt.Errorf("no network connection is set")
	}

	if !m.securityContext.ValidateOutgoingMessage(message) {
		return errors.New("invalid message")
	}

	err := m.networkConnection.SendMessageToNetworkPeer(address, message)
	if err != nil {
		return err
	}

	return nil
}

func (m *MessageSender) SetNetworkConnection(networkConnection network.NetworkConnection) {
	m.networkConnection = networkConnection
}


__________ ./skunk/application/port/network/networkInteractionPort.go:

package network

type OperationType int

const (
	SEND_MESSAGE   OperationType = iota
	SYNC_REQUEST   OperationType = iota
	SYNC_RESPONSE  OperationType = iota
	JOIN_CHAT      OperationType = iota
	LEAVE_CHAT     OperationType = iota
	INVITE_TO_CHAT OperationType = iota
	SEND_FILE      OperationType = iota
	SET_USERNAME   OperationType = iota
	TEST_MESSAGE   OperationType = iota
	TEST_MESSAGE_2 OperationType = iota
)

type Message struct {
	Id              string
	Timestamp       int64
	Content         string
	SenderID        string
	ReceiverID      string
	SenderAddress   string
	ReceiverAddress string
	ChatID          string
	Operation       OperationType
}

type NetworkObserver interface {
	Notify(message Message) error
}

type NetworkConnection interface {
	SubscribeToNetwork(observer NetworkObserver) error
	UnsubscribeFromNetwork(observer NetworkObserver) error
	SendMessageToNetworkPeer(address string, message Message) error
}


__________ ./skunk/application/port/frontend/frontendPort.go:

package frontend

type FrontendMessage struct {
	Timestamp int64
	Content   string
	FromUser  string // UserID
	ChatID    string // ChatID
	Operation OperationType
}

type OperationType int

const (
	SEND_MESSAGE   OperationType = iota
	CREATE_CHAT    OperationType = iota
	JOIN_CHAT      OperationType = iota
	LEAVE_CHAT     OperationType = iota
	INVITE_TO_CHAT OperationType = iota
	SEND_FILE      OperationType = iota
	SET_USERNAME   OperationType = iota
	TEST_MESSAGE   OperationType = iota
)

type FrontendObserver interface {
	Notify(message FrontendMessage) error
}

type Frontend interface {
	SubscribeToFrontend(observer FrontendObserver) error
	UnsubscribeFromFrontend(observer FrontendObserver) error
	SendToFrontend(message FrontendMessage) error // TODO: change to FrontendMessage
}


__________ ./skunk/application/port/store/storagePort.go:

package store

import "github.com/scherzma/Skunk/cmd/skunk/application/port/network"

type UserMessageStoragePort interface {
	PeerSetUsername(peerId string, chatId string, username string) error
}

type ChatActionStoragePort interface {
	PeerJoinedChat(peerId string, chatId string) error
	PeerLeftChat(peerId string, chatId string) error
	ChatCreated(chatName string, chatId string) error
}

type PublicKeyAddress struct {
	Address   string
	PublicKey string
}

type ChatInvitationStoragePort interface {
	InvitedToChat(messageID string, peers []PublicKeyAddress) error
	PeerGotInvitedToChat(peerId string, chatId string) error
	GetInvitations(peerId string) ([]string, error)
}

type SyncStoragePort interface {
	GetMissingInternalMessages(chatId string, inputMessageIDs []string) []string
	GetMissingExternalMessages(chatId string, inputMessageIDs []string) []string
}

type NetworkMessageStoragePort interface {
	StoreMessage(message network.Message) error
	RetrieveMessage(messageId string) (network.Message, error)
}

type ChatMessage struct {
	Username  string
	Content   string
	MessageId int64
	Timestamp int64
}

type Chat struct {
	ChatId   string
	ChatName string
}

type User struct {
	UserId   string
	Username string
}

type DisplayStoragePort interface {
	GetChats() ([]Chat, error)
	GetUsername(peerID, chatID string) (string, error)
	GetUsersInChat(chatID string) ([]User, error)
	GetPeers() ([]string, error)
	GetChatMessages(chatID string) ([]network.Message, error)
}


