------ /home/user/GolandProjects/Skunk/cmd/main.go:

package main

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/adapter/out/storage/storageSQLiteAdapter"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"reflect"
)

/*
type Message struct {
	Id              string
	Timestamp       int64
	Content         string
	SenderID        string
	ReceiverID      string
	SenderAddress   string
	ReceiverAddress string
	ChatID          string
	Operation       OperationType
}
*/

func main() {

	dbPath := "test.db"

	adapter := storageSQLiteAdapter.NewStorageSQLiteAdapter(dbPath)

	testMessages := []network.Message{
		{
			Id:              "msg1",
			Timestamp:       1620000000,
			Content:         "{\"message\": \"Hey everyone!\"}",
			SenderID:        "user1",
			ReceiverID:      "user2",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "user2.onion",
			ChatID:          "chat1",
			Operation:       network.SEND_MESSAGE,
		},
		{
			Id:              "sync1",
			Timestamp:       1620000060,
			Content:         "{\"existingMessageIds\": [\"msg1\"]}",
			SenderID:        "user2",
			ReceiverID:      "user1",
			SenderAddress:   "user2.onion",
			ReceiverAddress: "user1.onion",
			ChatID:          "chat1",
			Operation:       network.SYNC_REQUEST,
		},
		{
			Id:              "sync2",
			Timestamp:       1620000120,
			Content:         "[{\"Id\":\"msg2\",\"Timestamp\":1620000090,\"Content\":\"{\\\"message\\\": \\\"Hi User1!\\\"}\",\"SenderID\":\"user3\",\"ReceiverID\":\"user1\",\"SenderAddress\":\"user3.onion\",\"ReceiverAddress\":\"user1.onion\",\"ChatID\":\"chat1\",\"Operation\":0}]",
			SenderID:        "user1",
			ReceiverID:      "user2",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "user2.onion",
			ChatID:          "chat1",
			Operation:       network.SYNC_RESPONSE,
		},
		{
			Id:              "join1",
			Timestamp:       1620000180,
			Content:         "",
			SenderID:        "user4",
			ReceiverID:      "",
			SenderAddress:   "user4.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.JOIN_CHAT,
		},
		{
			Id:              "leave1",
			Timestamp:       1620000240,
			Content:         "",
			SenderID:        "user3",
			ReceiverID:      "",
			SenderAddress:   "user3.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.LEAVE_CHAT,
		},
		{
			Id:              "invite1",
			Timestamp:       1620000300,
			Content:         "{\"chatId\": \"chat1\", \"chatName\": \"Cool Chat\", \"peers\": [\"user5.onion\", \"user6.onion\"]}",
			SenderID:        "user1",
			ReceiverID:      "",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.INVITE_TO_CHAT,
		},
		{
			Id:              "file1",
			Timestamp:       1620000360,
			Content:         "{\"fileContent\": \"aGVsbG8gd29ybGQ=\"}",
			SenderID:        "user2",
			ReceiverID:      "",
			SenderAddress:   "user2.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.SEND_FILE,
		},
		{
			Id:              "setuser1",
			Timestamp:       1620000420,
			Content:         "{\"username\": \"CoolUser1\"}",
			SenderID:        "user1",
			ReceiverID:      "",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.SET_USERNAME,
		},
		{
			Id:              "test1",
			Timestamp:       1620000480,
			Content:         "This is a test message",
			SenderID:        "user1",
			ReceiverID:      "user2",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "user2.onion",
			ChatID:          "chat1",
			Operation:       network.TEST_MESSAGE,
		},
		{
			Id:              "test2",
			Timestamp:       1620000540,
			Content:         "This is another test message",
			SenderID:        "user2",
			ReceiverID:      "user4",
			SenderAddress:   "user2.onion",
			ReceiverAddress: "user4.onion",
			ChatID:          "chat1",
			Operation:       network.TEST_MESSAGE_2,
		},
	}

	// Store the test messages
	for _, msg := range testMessages {
		err := adapter.StoreMessage(msg)
		if err != nil {
			fmt.Printf("Error storing message: %v", err)
		}
	}

	fmt.Println("Messages stored")

	// Retrieve the messages and compare
	for _, msg := range testMessages {
		retrieved, err := adapter.RetrieveMessage(msg.Id)
		if err != nil {
			fmt.Printf("Error retrieving message: %v", err)
		}

		fmt.Println("storedccc ", msg)
		fmt.Println("retrieved ", retrieved)
		if !reflect.DeepEqual(msg, retrieved) {
			fmt.Printf("Retrieved message does not match stored message\n")
		}
	}

	fmt.Println("Messages retrieved")

	// Test GetChatMessages
	chatMessages, err := adapter.GetChatMessages("chat1")
	if err != nil {
		fmt.Printf("Error getting chat messages: %v", err)
	}

	if len(chatMessages) != len(testMessages) {
		fmt.Printf("Expected %d chat messages, got %d", len(testMessages), len(chatMessages))
	}

	// Test SetPeerUsername
	err = adapter.SetPeerUsername("CoolUser1", "user1", "chat1")
	if err != nil {
		fmt.Printf("Error setting peer username: %v", err)
	}

	username, err := adapter.GetUsername("user1", "chat1")
	if err != nil {
		fmt.Printf("Error getting username: %v", err)
	}

	if username != "CoolUser1" {
		fmt.Printf("Expected username 'CoolUser1', got '%s'", username)
	}

}


------ /home/user/GolandProjects/Skunk/cmd/skunk/adapter/in/networkMockAdapter/networkMockAdapter.go:

package networkMockAdapter

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"sync"
)

// NetworkMockAdapter is a mock adapter for the network
// It implements the NetworkConnection interface

var (
	mockConnection *MockConnection // singleton for testing purposes
	once           sync.Once
)

type MockConnection struct {
	subscribers []network.NetworkObserver
}

func GetMockConnection() *MockConnection {
	once.Do(func() {
		mockConnection = &MockConnection{}
	})
	return mockConnection
}

// SubscribeToNetwork is a mock function for the network
func (m *MockConnection) SubscribeToNetwork(observer network.NetworkObserver) error {
	m.subscribers = append(m.subscribers, observer)
	return nil
}

// UnsubscribeFromNetwork is a mock function for the network
func (m *MockConnection) UnsubscribeFromNetwork(observer network.NetworkObserver) error {
	for i, sub := range m.subscribers {
		if sub == observer {
			m.subscribers = append(m.subscribers[:i], m.subscribers[i+1:]...)
			break
		}
	}
	return nil
}

// SendMessageToNetworkPeer is a mock function for the network
func (m *MockConnection) SendMessageToNetworkPeer(address string, message network.Message) error {
	fmt.Println("Sending message to: " + address)
	fmt.Println("Message: ", message)
	return nil
}

// SendMockNetworkMessageToSubscribers is a mock function for the network
func (m *MockConnection) SendMockNetworkMessageToSubscribers(message network.Message) error {
	for _, sub := range m.subscribers {
		sub.Notify(message)
	}
	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/adapter/in/peer/peer.go:

package peer

import (
	"context"
	"fmt"
	"log"
	"net"
	"net/http"
	"sync"
	"time"

	"github.com/gorilla/websocket"
	"golang.org/x/net/proxy"
)

const (
	MaxConns          = 64                           // MaxConns defines the maximum number of concurrent websocket connections allowed.
	connWait          = 1 * time.Minute              // connWait specifies the timeout for connecting to another peer.
	writeWait         = 20 * time.Second             // writeWait specifies the timeout for writing to another peer. has to be high when running over tor
	shutdownWait      = 0 * time.Second              // shutdownWait specifies the wait time for shutting down the HTTP server. (optional for later)
	readRateInterval  = 2 * time.Second              // readRateInterval specifies the rate at which it will it is tried to read a message from every connection.
	readWait          = (readRateInterval * 9) / 10  // readWait specifies the time for trying to read a message from a connection. Needs to be less than readRateInterval
	heartbeatInterval = 1 * time.Minute              // heartbeatInterval specifies the time interval between consecutive heartbeat messages. when running over tor this should be high
	pongWait          = (heartbeatInterval * 9) / 10 // pongWait specifies the time a ping response can need before the connection gets classified as closed during an heartbeat. Needs to be less than heartbeatInteval
	maxMessageSize    = 512                          // maxMessageSize defines the maximum message size allowed from peer. (bytes)
)

var upgrader = websocket.Upgrader{
	ReadBufferSize:  maxMessageSize,
	WriteBufferSize: maxMessageSize,
}

// Peer encapsulates the state and functionality for a network peer, including its connections,
// configuration parameters, and synchronisation primitives for safe concurrent access.
type Peer struct {
	client     *http.Client               // client is used to make HTTP requests with a custom transport, supporting proxy configuration.
	readConns  map[string]*websocket.Conn // readConns maintains a map of active websocket connections for reading, indexed by the remote address. Note: Maybe we can later use a sync.Map
	mapRWLock  sync.RWMutex               // mapRWLock provides concurrent access control for readConns map.
	writeConn  *websocket.Conn            // writeConn is a dedicated websocket connection reserved for writing messages.
	readMutex  sync.Mutex                 // readMutex provides concurrent access control for ReadMessage.
	writeMutex sync.Mutex                 // writeMutex provides concurrent access control for WriteMessage.
	quitch     chan struct{}              // quitch is used to signal the shutdown process for the peer.
	Hostname   string                     // Hostname specifies the network address of the peer.
	Port       string                     // Port on which the peer listens for incoming connections.
	Address    string                     // Address specifies the complete websocket address: ws://Hostname:Port
	ProxyAddr  string                     // ProxyAddr specifies the address of SOCKS5 proxy, if used for connections.
}

// NewPeer initializes a new Peer instance with the given network settings.
// It also configures the peer's HTTP client for optimal proxy support.
// hostname needs to include .de, .onion...
func NewPeer(hostname string, localPort string, remotePort string, proxyAddr string) (*Peer, error) {
	if remotePort == "" {
		remotePort = localPort
	}
	transport, err := createTransport(proxyAddr) // Attempts to create an HTTP transport, optionally configured with a SOCKS5 proxy.
	if err != nil {
		return nil, fmt.Errorf("failed to create SOCKS5 dialer: %w", err)
	}

	p := Peer{
		readConns: make(map[string]*websocket.Conn),
		Hostname:  hostname,
		Port:      localPort,
		Address:   fmt.Sprintf("ws://%s:%s", hostname, remotePort),
		ProxyAddr: proxyAddr,
		quitch:    make(chan struct{}),
		client: &http.Client{
			Transport: transport,
		},
	}

	// starts the heartbeat mechanism
	p.startHeartbeat()

	return &p, nil
}

// createTransport configures and returns an HTTP transport mechanism.
// If a proxy address is provided, it configures the transport to use a SOCKS5 proxy.
func createTransport(proxyAddr string) (*http.Transport, error) {
	if proxyAddr != "" {
		dialer, err := proxy.SOCKS5("tcp", proxyAddr, nil, nil)
		if err != nil {
			return nil, err
		}
		return &http.Transport{
			Dial: dialer.Dial,
		}, nil
	}
	return &http.Transport{}, nil
}

// Listen sets up an HTTP server and starts listening on the configured port for incoming websocket connections.
// It also starts a goroutine for graceful shutdown handling upon receiving a signal on the quitch channel.
// Optionally it uses the listener provided by tor.
func (p *Peer) Listen(l net.Listener) {
	select {
	case _, ok := <-p.quitch:
		if !ok {
			p.quitch = make(chan struct{}) // if closed, then reopen channel
		}
	default:
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/", p.handler) // Registers the main handler.

	srv := &http.Server{
		Handler: mux,
	}

	go func() {
		var err error
		if l != nil {
			// Use the provided listener
			err = srv.Serve(l)
		} else {
			// Listen on the specified port if no listener is provided
			srv.Addr = ":" + p.Port
			err = srv.ListenAndServe()
		}
		if err != http.ErrServerClosed {
			log.Printf("HTTP server listen failed: %v", err)
		}
	}()

	// Shuts down server when quitch gets closed
	go func() {
		select {
		case <-p.quitch:
			shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)

			if err := srv.Shutdown(shutdownCtx); err != nil {
				log.Printf("HTTP server shutdown failed: %v", err)
			}
			defer cancel()
		}
	}()
}

// SetWriteConn designates a specific websocket connection, identified by its address, as the sole connection for sending messages.
// It verifies that the peer is currently connected to the specified address before setting the connection.
func (p *Peer) SetWriteConn(address string) error {
	if len(p.readConns) == 0 {
		return fmt.Errorf("peer is not connected to any address")
	}

	if !p.isConnectedTo(address) {
		return fmt.Errorf("peer is not connected to address: %s", address)
	}

	p.mapRWLock.RLock()
	p.writeConn = p.readConns[address]
	p.mapRWLock.RUnlock()
	return nil
}

// Connect establishes a new websocket connection to the specified address and adds it to the pool of read connections.
// It performs connection setup with a timeout and utilizes the configured HTTP client for the connection attempt.
func (p *Peer) Connect(address string) error {
	if address == "" {
		return fmt.Errorf("empty address is not a valid address")
	}

	if address == p.Address {
		return fmt.Errorf("can't connect to own address: %s", p.Address)
	}

	if p.isConnectedTo(address) {
		return fmt.Errorf("peer is already connected to address: %s", address)
	}

	dialer := websocket.Dialer{
		HandshakeTimeout: connWait,
	}

	if p.client.Transport != nil {
		if transport, ok := p.client.Transport.(*http.Transport); ok {
			dialer.NetDial = transport.Dial
		}
	}

	// Set peer address as header so that the other peer knows at which port we are listening
	headers := http.Header{}
	headers.Add("X-Peer-Address", p.Address)

	c, _, err := dialer.Dial(address, headers)

	if err != nil {
		return fmt.Errorf("failed to dial websocket: %v", err)
	}

	return p.handleNewConnection(c, address)
}

// ReadMessage attempts to read a single message from the specified websocket connection.
// It locks the readMutex to ensure exclusive access to the connection during the read operation.
func (p *Peer) readMessage(conn *websocket.Conn, address string) (string, error) {
	if conn == nil {
		return "", fmt.Errorf("invalid connection: connection is nil")
	}

	conn.SetReadLimit(maxMessageSize)
	conn.SetReadDeadline(time.Now().Add(readWait))
	p.readMutex.Lock()
	_, messageBytes, err := conn.ReadMessage()
	p.readMutex.Unlock()
	if err != nil {
		if p.checkConnIsClosed(address, err) {
			return "", err
		} else {
			return "", nil
		}
	}

	return string(messageBytes), nil
}

// ReadMessages starts readMessage for every conn in readConns in the readRate interval.
func (p *Peer) ReadMessages(messageCh chan<- string, errorCh chan<- error) {
	ticker := time.NewTicker(readRateInterval)
	go func() {
		for {
			select {
			case <-ticker.C:
				p.mapRWLock.RLock()
				for addr, conn := range p.readConns {
					go func() {
						msg, err := p.readMessage(conn, addr)
						if err != nil {
							errorCh <- err
						} else if msg != "" { // "" can happen when an error occurs when reading from
							// the connection but the error is not due to the
							// connection being closed.
							messageCh <- msg
						}
					}()
				}
				p.mapRWLock.RUnlock()
			case <-p.quitch:
				ticker.Stop()
				return
			}
		}
	}()
}

// WriteMessage sends a message using the designated write connection.
// It locks the writeMutex to ensure exclusive access to the connection during the write operation.
func (p *Peer) WriteMessage(message string) error {
	if p.writeConn == nil {
		return fmt.Errorf("no write connection is set")
	}

	// Append From p.Address: to message so that the other peers knows which peer sent him the message.
	fullMessage := fmt.Sprintf("From %s: %s", p.Address, message)

	p.writeConn.SetWriteDeadline(time.Now().Add(writeWait))
	p.writeMutex.Lock()
	err := p.writeConn.WriteMessage(websocket.TextMessage, []byte(fullMessage))
	p.writeMutex.Unlock()
	if err != nil {
		p.checkConnIsClosed(p.writeConn.RemoteAddr().String(), err)
		return err
	}

	return nil
}

// Shutdown initiates the shutdown process for the peer, closing all active websocket connections.
// and signaling the quitch channel to stop the HTTP server.
func (p *Peer) Shutdown() {
	p.mapRWLock.RLock()
	defer p.mapRWLock.RUnlock()

	for _, conn := range p.readConns {
		conn.Close()
	}
	p.readConns = make(map[string]*websocket.Conn) // Resets the connection pool.
	p.writeConn = nil

	close(p.quitch) // Signals the shutdown listener to initiate server shutdown.
}

// handler is the HTTP request handler for upgrading incoming requests to websocket connections.
// It accepts a websocket connection and adds it to the pool of read connections.
func (p *Peer) handler(w http.ResponseWriter, r *http.Request) {
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Printf("failed to upgrade incoming connection: %v", err)
		return
	}

	if err := p.handleNewConnection(conn, r.Header.Get("X-Peer-Address")); err != nil {
		log.Printf("failed to handle new connection: %v", err)
		conn.Close() // TO-DO: Send and handle error that the peer reached its maximum of connections.
	}
}

// handleNewConnection adds a newly established websocket connection to the readConns map.
// It ensures that the total number of connections does not exceed the maximum allowed.
func (p *Peer) handleNewConnection(conn *websocket.Conn, address string) error {
	if len(p.readConns) >= MaxConns {
		return fmt.Errorf("maximum number of connections reached: %d", MaxConns)
	}

	p.mapRWLock.Lock()
	p.readConns[address] = conn
	p.mapRWLock.Unlock()
	return nil
}

// StartHearbeat initiates a periodic hearbeat mechanism for all active connections.
// It sends a ping message at regular intervals to each connection to ensure they are alive.
func (p *Peer) startHeartbeat() {
	ticker := time.NewTicker(heartbeatInterval)
	go func() {
		for {
			select {
			case <-ticker.C: // On each tick, send heartbeat to all connections.
				p.sendHeartbeatToAll()
			case <-p.quitch:
				ticker.Stop()
				return
			}
		}
	}()
}

// sendHearbeatToAll sends a hearbeat signal (ping) to each active connection.
// If a connection fails to respond to the heartbeat, it removes the connection.
func (p *Peer) sendHeartbeatToAll() {
	//p.writeMutex.Lock()
	//defer p.writeMutex.Unlock()

	// THIS IS NOT GOOD
	for address, conn := range p.readConns {
		if conn == nil {
			p.mapRWLock.Lock()
			delete(p.readConns, address)
			p.mapRWLock.Unlock()
		} else {
			conn.SetWriteDeadline(time.Now().Add(pongWait))
			if err := conn.WriteMessage(websocket.PingMessage, []byte{}); err != nil {
				p.mapRWLock.Lock()
				delete(p.readConns, address) // Optionally, we could try to reinitialize the connection here.
				p.mapRWLock.Unlock()
			}
		}
	}
}

// isConnectedTo checks if there is an existing websocket connection to the specified address.
func (p *Peer) isConnectedTo(address string) bool {
	p.mapRWLock.RLock()
	_, ok := p.readConns[address]
	p.mapRWLock.RUnlock()
	return ok
}

// checkConnIsClosed evaluates if an error during a read or write operation was due to the connection being closed.
// If so, it removes the connection from the readConns map to prevent furter use.
func (p *Peer) checkConnIsClosed(address string, err error) bool {
	if websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) {
		p.mapRWLock.Lock()
		delete(p.readConns, address)
		p.mapRWLock.Unlock()
		return true
	}
	return false
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/adapter/in/tor/tor.go:

package tor

import (
	"context"
	"crypto/ed25519"
	"crypto/rand"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"time"

	"github.com/cretz/bine/tor"
	"github.com/ipsn/go-libtor"
)

// TorConfig holds configuration parameters for a Tor instance.
type TorConfig struct {
	DataDir              string // directory for storing tor data files.
	SocksPort            string // SOCKS5 proxy port for tor connection.
	LocalPort            string // local port for incoming connections.
	RemotePort           string // remote port for hiddenservice.
	DeleteDataDirOnClose bool   // flag to delete data directory on closing tor.
	ReusePrivateKey      bool   // flag to reuse the private key across sessions.
	UseEmbedded          bool   // use the embedded tor process (go-libtor)
}

// Tor wraps a tor configuration and instance for managing tor services.
type Tor struct {
	torConfig   *TorConfig // configuration for the tor instance.
	torInstance *tor.Tor   // the tor instance.
}

// NewTor initializes a new tor instance with the provided configuration.
func NewTor(torConfig *TorConfig) (*Tor, error) {
	// basic validation of configuration paramters.
	if torConfig.SocksPort == "" {
		return nil, fmt.Errorf("no tor socks port provided")
	}
	if torConfig.SocksPort == "9050" {
		return nil, fmt.Errorf("can't use 9050 as tor socks port")
	}
	if torConfig.LocalPort == "" {
		return nil, fmt.Errorf("no local port given")
	}
	if torConfig.RemotePort == "" {
		return nil, fmt.Errorf("no remote port given")
	}
	if torConfig.LocalPort == torConfig.SocksPort || torConfig.RemotePort == torConfig.SocksPort {
		return nil, fmt.Errorf("ports for hiddenservice can't match tor socks port")
	}

	if torConfig.DataDir == "" {
		torConfig.DataDir = "tor-data"
	}

	return &Tor{
		torConfig:   torConfig,
		torInstance: nil,
	}, nil
}

// StarTor starts the tor instance with the configured settings.
func (t *Tor) StartTor() error {
	if t.torInstance != nil {
		return fmt.Errorf("can't start the same tor instance twice")
	}

	conf := &tor.StartConf{
		NoAutoSocksPort: true, // needs to be true to be able to set a custom socks port
		ExtraArgs:       []string{"--SocksPort", t.torConfig.SocksPort},
		DataDir:         t.torConfig.DataDir,
		DebugWriter:     os.Stdout, // just for testing. might change later
	}
	// if configured use the go-libtor embedded tor process creator
	if t.torConfig.UseEmbedded {
		conf.ProcessCreator = libtor.Creator
	}

	torInstance, err := tor.Start(nil, conf)
	if err != nil {
		return err
	}

	t.torInstance = torInstance
	return nil
}

// StartHiddenService starts a hidden service using the current tor instance.
func (t *Tor) StartHiddenService() (*tor.OnionService, error) {
	if t.torInstance == nil {
		return nil, fmt.Errorf("tor needs to be started before a hiddenservice can be created")
	}

	// LocalPort and RemotePort are strings because we want to provide a unified interface for the tor config
	// where you don't need to figure out which port / address has which type.
	remotePortInt, err := strconv.Atoi(t.torConfig.RemotePort)
	if err != nil {
		return nil, err
	}
	localPortInt, err := strconv.Atoi(t.torConfig.LocalPort)
	if err != nil {
		return nil, err
	}

	conf := &tor.ListenConf{
		Version3:    true, // uses v3 onion service and ed25519 key
		LocalPort:   localPortInt,
		RemotePorts: []int{remotePortInt},
	}

	// attempt to read the private key if ReusePrivateKey is true
	if t.torConfig.ReusePrivateKey {
		privateKeyPath := filepath.Join(t.torConfig.DataDir, "hidden_service_private_key")
		var privateKey ed25519.PrivateKey

		if _, err := os.Stat(privateKeyPath); err == nil {
			keyData, readErr := os.ReadFile(privateKeyPath)
			if readErr != nil {
				return nil, fmt.Errorf("failed to read private key: %v", readErr)
			}
			privateKey = ed25519.PrivateKey(keyData)
		} else {
			// generate a new private key
			_, privKey, genErr := ed25519.GenerateKey(rand.Reader)
			if genErr != nil {
				return nil, fmt.Errorf("failed to generate private key: %v", genErr)
			}
			privateKey = privKey
			// save newly generated private key
			if err := os.WriteFile(privateKeyPath, privKey.Seed(), 0600); err != nil {
				return nil, fmt.Errorf("failed to save private key: %v", err)
			}
		}
		conf.Key = privateKey
	}

	// wait at most a few minutes to publish the service
	listenCtx, listenCancel := context.WithTimeout(context.Background(), 3*time.Minute)
	defer listenCancel()

	onion, err := t.torInstance.Listen(listenCtx, conf)
	if err != nil {
		return nil, err
	}

	return onion, nil
}

// StopTor stops the tor instance (and hiddenservice) and handles cleanup.
func (t *Tor) StopTor() error {
	err := t.torInstance.Close()
	if err != nil {
		return fmt.Errorf("error stopping tor: %v", err)
	}
	t.torInstance = nil

	// clean up data directory if needed.
	if t.torConfig.DataDir != "" && t.torConfig.DeleteDataDirOnClose {
		if err := os.RemoveAll(t.torConfig.DataDir); err != nil {
			return fmt.Errorf("failed to remove data dir %v: %v", t.torConfig.DataDir, err)
		}
	}
	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/adapter/out/frontend/mockFrontend/mockFrontendAdapter.go:

package mockFrontend

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/frontend"
	"sync"
)

var (
	mockFrontendInstance *MockFrontend
	once                 sync.Once
)

type MockFrontend struct {
	observers []frontend.FrontendObserver
}

func GetMockFrontendInstance() *MockFrontend {
	once.Do(func() {
		mockFrontendInstance = &MockFrontend{
			observers: make([]frontend.FrontendObserver, 0),
		}
	})
	return mockFrontendInstance
}

func (mf *MockFrontend) SubscribeToFrontend(observer frontend.FrontendObserver) error {
	mf.observers = append(mf.observers, observer)
	return nil
}

func (mf *MockFrontend) UnsubscribeFromFrontend(observer frontend.FrontendObserver) error {
	for i, obs := range mf.observers {
		if obs == observer {
			mf.observers = append(mf.observers[:i], mf.observers[i+1:]...)
			return nil
		}
	}
	return fmt.Errorf("observer not found")
}

func (mf *MockFrontend) SendToFrontend(message frontend.FrontendMessage) error {
	for _, observer := range mf.observers {
		err := observer.Notify(message)
		if err != nil {
			return err
		}
	}
	return nil
}

func (mf *MockFrontend) SendMockFrontendMessageToSubscribers(message frontend.FrontendMessage) error {
	return mf.SendToFrontend(message)
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/adapter/out/storage/database.sql:

create table Chats
(
    chat_id varchar(1024) not null
        constraint Chats_pk
            primary key,
    name    varchar(40)   not null
);

create table Peers
(
    peer_id    integer       not null
        constraint Peers_pk
            primary key autoincrement,
    public_key varchar(1024) not null,
    address    varchar(1024) not null
);

create table ChatMembers
(
    chat_member_id integer       not null
        constraint ChatMembers_pk
            primary key autoincrement,
    timestamp      integer       not null,
    peer_id        varchar(1024) not null
        constraint ChatMembers_Peers_peer_id_fk
            references Peers
            on update cascade,
    chat_id        varchar(1024) not null
        constraint ChatMembers_Chats_chat_id_fk
            references Chats
            on update cascade,
    username       varchar(50)
);

create table Messages
(
    message_id       varchar(1024) not null
        constraint Messages_pk
            primary key,
    content          text,
    timestamp        integer       not null,
    operation        integer       not null,
    sender_peer_id   varchar(1024) not null
        constraint Messages_Peers_peer_id_fk
            references Peers
            on update cascade,
    chat_id          varchar(1024) not null
        constraint Messages_Chats_chat_id_fk
            references Chats
            on update cascade,
    receiver_peer_id varchar(1024) not null
        constraint Messages_Peers_peer_id_fk_2
            references Peers,
    sender_address   varchar(1024) not null,
    receiver_address varchar(1024) not null
);

create table Invitations
(
    invitation_id     integer       not null
        constraint Invitations_pk
            primary key autoincrement,
    invitation_status integer       not null,
    message_id        varchar(1024) not null
        constraint Invitations_Messages_message_id_fk
            references Messages
);

create table PeersInInvitedChat
(
    public_key      varchar(1024) not null,
    invited_peer_id integer       not null
        constraint PeersInInvitedChat_pk
            primary key autoincrement,
    address         varchar(1024) not null,
    invitation_id   integer       not null
        constraint PeersInInvitedChat_Invitations_invitation_id_fk
            references Invitations
);



------ /home/user/GolandProjects/Skunk/cmd/skunk/adapter/out/storage/storageMessageQueueSQLite.go:

package storage

import (
	"database/sql"
	_ "github.com/mattn/go-sqlite3"
	"log"
)

type StoreMessageQueueSQLite struct {
}

func (s *StoreMessageQueueSQLite) StoreMessageQueue(string2 string) error {
	db, err := sql.Open("sqlite3", "./yourdatabase.db")
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	// Check for table existence and create if not exists
	createTableSQL := `CREATE TABLE IF NOT EXISTS exampleTable (
        "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,     
        "data" TEXT
    );` // SQL Statement for Create Table

	_, err = db.Exec(createTableSQL)
	if err != nil {
		log.Fatal(err)
	}
	return nil
}

func (s *StoreMessageQueueSQLite) RetriveMessageQueue() (string, error) {
	return "", nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/adapter/out/storage/sqlStatements.sql:


/*
    type Message struct {
	Id              string
	Timestamp       int64
	Content         string
	SenderID        string
	ReceiverID      string
	SenderAddress   string
	ReceiverAddress string
	ChatID          string
	Operation       OperationType
}
*/

-- Peer Set Username
UPDATE ChatMembers
SET username = ?
WHERE peer_id = ? AND chat_id = ?;

-- Peer Joined Chat
INSERT INTO ChatMembers (peer_id, chat_id)
SELECT ?, ?
    WHERE NOT EXISTS(SELECT 1 FROM ChatMembers WHERE peer_id=? AND chat_id=?);

-- Peer Left Chat
DELETE FROM ChatMembers
WHERE peer_id=? AND chat_id=?;

-- Chat Created
INSERT INTO Chats (chat_id, name)
SELECT ?, ?
    WHERE NOT EXISTS(SELECT 1 FROM Chats WHERE chat_id=? AND name=?);

-- Invited To Chat
-- type publicKeyAddress struct {
-- 	Address string
-- 	PublicKey string
-- }
-- InvitatedToChat(messageId string, peers []publicKeyAddress) error
INSERT INTO Invitations (message_id)
SELECT ?
    WHERE NOT EXISTS(SELECT 1 FROM Invitations WHERE message_id = ?);

-- For each peer
INSERT INTO PeersInInvitedChat (public_key, address, invitation_id)
SELECT ?, ?, (SELECT Invitations.invitation_id FROM Invitations WHERE message_id = ?)
    WHERE NOT EXISTS(SELECT 1 FROM PeersInInvitedChat WHERE public_key = ? AND address = ? AND invitation_id = (SELECT Invitations.invitation_id FROM Invitations WHERE message_id = ?));

-- PeerGotInvitedToChat
-- PeerGotInvitedToChat(message network.Message) error


-- GetInvitations(peerId string) []string
SELECT m.*, i.invitation_status FROM Messages m, Invitations i WHERE m.receiver_peer_id = ?
                                                                 AND i.message_id = m.message_id AND m.operation = ?;

-- GetMissingInternalMessages(chatId string, inputMessageIDs []string) []string
SELECT * FROM Messages
WHERE message_id NOT IN (?, ?) AND chat_id = ?;

-- GetMissingExternalMessages(chatId string, inputMessageIDs []string) []string
SELECT * FROM Messages
WHERE (?, ?) NOT IN (SELECT message_id FROM Messages WHERE chat_id = ?) AND chat_id = ?;

-- StoreMessage(message network.Message) error
INSERT INTO Messages (message_id, date, content, sender_peer_id, receiver_peer_id, sender_address, receiver_address, chat_id, operation)
SELECT ?, ?, ?, ?, ?, ? ,?, ?, ?
    WHERE NOT EXISTS(SELECT 1 FROM Messages WHERE message_id = ?);

-- RetrieveMessage(messageId string) (network.Message, error)
SELECT * FROM Messages WHERE message_id = ?;

-- GetChats() []Chat
SELECT * FROM Chats;

-- GetUsername(peerId string, chatId string) string
SELECT username FROM ChatMembers WHERE peer_id = ? AND chat_id = ?;

-- GetUsersInChat(chatId string) []User
SELECT * FROM ChatMembers WHERE chat_id = ?;

-- GetPeers() []string
SELECT * FROM Peers;

-- GetChatMessages(chatId string) []ChatMessage
SELECT * FROM Messages WHERE chat_id = ?;


------ /home/user/GolandProjects/Skunk/cmd/skunk/adapter/out/storage/storageSQLiteAdapter/StorageSQLiteAdapter.go:

package storageSQLiteAdapter

import (
	"database/sql"
	"fmt"
	_ "github.com/mattn/go-sqlite3"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"log"
	"strings"
)

type StorageSQLiteAdapter struct {
	db *sql.DB
}

func NewStorageSQLiteAdapter(dbPath string) *StorageSQLiteAdapter {
	db, err := sql.Open("sqlite3", dbPath)
	if err != nil {
		log.Fatal(err)
	}

	// Create tables if they don't exist
	adapter := &StorageSQLiteAdapter{db: db}
	adapter.CreateTables()

	return adapter
}

func (a *StorageSQLiteAdapter) CreateTables() {
	sqlCommands := "CREATE TABLE IF NOT EXISTS Chats (\n    chat_id VARCHAR(1024) NOT NULL CONSTRAINT Chats_pk PRIMARY KEY,\n    name VARCHAR(40) NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS Peers (\n    peer_id INTEGER NOT NULL CONSTRAINT Peers_pk PRIMARY KEY AUTOINCREMENT,\n    public_key VARCHAR(1024) NOT NULL,\n    address VARCHAR(1024) NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS ChatMembers (\n    chat_member_id INTEGER NOT NULL CONSTRAINT ChatMembers_pk PRIMARY KEY AUTOINCREMENT,\n    date INTEGER NOT NULL,\n    peer_id VARCHAR(1024) NOT NULL CONSTRAINT ChatMembers_Peers_peer_id_fk REFERENCES Peers ON UPDATE CASCADE,\n    chat_id VARCHAR(1024) NOT NULL CONSTRAINT ChatMembers_Chats_chat_id_fk REFERENCES Chats ON UPDATE CASCADE,\n    username VARCHAR(50)\n);\n\nCREATE TABLE IF NOT EXISTS Messages (\n    message_id VARCHAR(1024) NOT NULL CONSTRAINT Messages_pk PRIMARY KEY,\n    content TEXT,\n    date INTEGER NOT NULL,\n    operation INTEGER NOT NULL,\n    sender_peer_id VARCHAR(1024) NOT NULL CONSTRAINT Messages_Peers_peer_id_fk REFERENCES Peers ON UPDATE CASCADE,\n    chat_id VARCHAR(1024) NOT NULL CONSTRAINT Messages_Chats_chat_id_fk REFERENCES Chats ON UPDATE CASCADE,\n    receiver_peer_id VARCHAR(1024) NOT NULL CONSTRAINT Messages_Peers_peer_id_fk_2 REFERENCES Peers,\n    sender_address VARCHAR(1024) NOT NULL,\n    receiver_address VARCHAR(1024) NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS Invitations (\n    invitation_id INTEGER NOT NULL CONSTRAINT Invitations_pk PRIMARY KEY AUTOINCREMENT,\n    invitation_status INTEGER NOT NULL,\n    message_id VARCHAR(1024) NOT NULL CONSTRAINT Invitations_Messages_message_id_fk REFERENCES Messages\n);\n\nCREATE TABLE IF NOT EXISTS PeersInInvitedChat (\n    public_key VARCHAR(1024) NOT NULL,\n    invited_peer_id INTEGER NOT NULL CONSTRAINT PeersInInvitedChat_pk PRIMARY KEY AUTOINCREMENT,\n    address VARCHAR(1024) NOT NULL,\n    invitation_id INTEGER NOT NULL CONSTRAINT PeersInInvitedChat_Invitations_invitation_id_fk REFERENCES Invitations\n);\n"
	_, err := a.db.Exec(sqlCommands)
	if err != nil {
		log.Fatal(err)
	}
}

func (a *StorageSQLiteAdapter) SetPeerUsername(username, peerID, chatID string) error {
	stmt, err := a.db.Prepare("UPDATE ChatMembers SET username = ? WHERE peer_id = ? AND chat_id = ?")
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(username, peerID, chatID)
	return err
}

func (a *StorageSQLiteAdapter) PeerJoinedChat(peerID, chatID string) error {
	stmt, err := a.db.Prepare("INSERT INTO ChatMembers (date, peer_id, chat_id) SELECT datetime('now'), ?, ? WHERE NOT EXISTS (SELECT 1 FROM ChatMembers WHERE peer_id = ? AND chat_id = ?)")
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(peerID, chatID, peerID, chatID)
	return err
}

func (a *StorageSQLiteAdapter) PeerLeftChat(peerID, chatID string) error {
	stmt, err := a.db.Prepare("DELETE FROM ChatMembers WHERE peer_id = ? AND chat_id = ?")
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(peerID, chatID)
	return err
}

func (a *StorageSQLiteAdapter) CreateChat(chatID, name string) error {
	stmt, err := a.db.Prepare("INSERT INTO Chats (chat_id, name) SELECT ?, ? WHERE NOT EXISTS (SELECT 1 FROM Chats WHERE chat_id = ?)")
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(chatID, name, chatID)
	return err
}

type PublicKeyAddress struct {
	Address   string
	PublicKey string
}

func (a *StorageSQLiteAdapter) InvitedToChat(messageID string, peers []PublicKeyAddress) error {
	tx, err := a.db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	stmt, err := tx.Prepare("INSERT INTO Invitations (invitation_status, message_id) SELECT 0, ? WHERE NOT EXISTS (SELECT 1 FROM Invitations WHERE message_id = ?)")
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(messageID, messageID)
	if err != nil {
		return err
	}

	stmt, err = tx.Prepare("INSERT INTO PeersInInvitedChat (public_key, address, invitation_id) SELECT ?, ?, (SELECT invitation_id FROM Invitations WHERE message_id = ?) WHERE NOT EXISTS (SELECT 1 FROM PeersInInvitedChat WHERE public_key = ? AND address = ? AND invitation_id = (SELECT invitation_id FROM Invitations WHERE message_id = ?))")
	if err != nil {
		return err
	}
	defer stmt.Close()

	for _, peer := range peers {
		_, err = stmt.Exec(peer.PublicKey, peer.Address, messageID, peer.PublicKey, peer.Address, messageID)
		if err != nil {
			return err
		}
	}

	err = tx.Commit()
	return err
}

func (a *StorageSQLiteAdapter) PeerGotInvitedToChat(peerID, chatID string) error {
	// Implement the logic to store a peer getting invited to a chat in the database
	// ...
	return nil
}

func (a *StorageSQLiteAdapter) GetInvitations(peerID string) ([]string, error) {
	rows, err := a.db.Query(`
		SELECT m.*, i.invitation_status 
		FROM Messages m
		JOIN Invitations i ON i.message_id = m.message_id
		WHERE m.receiver_peer_id = ? AND m.operation = ?
	`, peerID, network.INVITE_TO_CHAT)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var invitations []string
	for rows.Next() {
		var invitation string
		err := rows.Scan(&invitation)
		if err != nil {
			return nil, err
		}
		invitations = append(invitations, invitation)
	}

	return invitations, nil
}

func (a *StorageSQLiteAdapter) GetMissingInternalMessages(chatID string, inputMessageIDs []string) ([]string, error) {
	query := "SELECT message_id FROM Messages WHERE chat_id = ? AND message_id NOT IN (?" + strings.Repeat(",?", len(inputMessageIDs)-1) + ")"
	args := make([]interface{}, len(inputMessageIDs)+1)
	args[0] = chatID
	for i, id := range inputMessageIDs {
		args[i+1] = id
	}

	rows, err := a.db.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var messages []string
	for rows.Next() {
		var message string
		err := rows.Scan(&message)
		if err != nil {
			return nil, err
		}
		messages = append(messages, message)
	}

	return messages, nil
}

func (a *StorageSQLiteAdapter) GetMissingExternalMessages(chatID string, inputMessageIDs []string) ([]string, error) {
	query := "SELECT message_id FROM Messages WHERE chat_id = ? AND message_id NOT IN (SELECT message_id FROM Messages WHERE chat_id = ? AND message_id IN (?" + strings.Repeat(",?", len(inputMessageIDs)-1) + "))"
	args := make([]interface{}, len(inputMessageIDs)+2)
	args[0] = chatID
	args[1] = chatID
	for i, id := range inputMessageIDs {
		args[i+2] = id
	}

	rows, err := a.db.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var messages []string
	for rows.Next() {
		var message string
		err := rows.Scan(&message)
		if err != nil {
			return nil, err
		}
		messages = append(messages, message)
	}

	return messages, nil
}

func (a *StorageSQLiteAdapter) StoreMessage(message network.Message) error {
	// Check if sender exists in Peers table, and insert if not
	err := a.insertPeerIfNotExists(message.SenderID, message.SenderAddress)
	if err != nil {
		return err
	}

	// Check if receiver exists in Peers table, and insert if not
	err = a.insertPeerIfNotExists(message.ReceiverID, message.ReceiverAddress)
	if err != nil {
		return err
	}

	stmt, err := a.db.Prepare(`
        INSERT INTO Messages (message_id, date, content, sender_peer_id, receiver_peer_id, sender_address, receiver_address, chat_id, operation)
        SELECT ?, ?, ?, (SELECT peer_id FROM Peers WHERE public_key = ?), (SELECT peer_id FROM Peers WHERE public_key = ?), ?, ?, ?, ?
        WHERE NOT EXISTS (SELECT 1 FROM Messages WHERE message_id = ?)
    `)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(
		message.Id, message.Timestamp, message.Content, message.SenderID, message.ReceiverID,
		message.SenderAddress, message.ReceiverAddress, message.ChatID, message.Operation, message.Id,
	)
	return err
}

func (a *StorageSQLiteAdapter) insertPeerIfNotExists(publicKey, address string) error {
	stmt, err := a.db.Prepare(`
        INSERT INTO Peers (public_key, address)
        SELECT ?, ?
        WHERE NOT EXISTS (SELECT 1 FROM Peers WHERE public_key = ?)
    `)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(publicKey, address, publicKey)
	return err
}

func (a *StorageSQLiteAdapter) RetrieveMessage(messageID string) (network.Message, error) {
	row := a.db.QueryRow(`
		SELECT m.message_id, m.date, m.content, m.operation, p.public_key, p2.public_key, m.sender_address, m.receiver_address, m.chat_id
		FROM Messages m, Peers p, Peers p2
		WHERE message_id = ? AND m.sender_peer_id = p.peer_id AND m.receiver_peer_id = p2.peer_id
	`, messageID)

	var message network.Message
	err := row.Scan(
		&message.Id, &message.Timestamp, &message.Content, &message.Operation, &message.SenderID, &message.ReceiverID,
		&message.SenderAddress, &message.ReceiverAddress, &message.ChatID,
	)
	if err != nil {
		return network.Message{}, err
	}

	return message, nil
}

type Chat struct {
	ChatID string
	Name   string
}

func (a *StorageSQLiteAdapter) GetChats() ([]Chat, error) {
	rows, err := a.db.Query("SELECT chat_id, name FROM Chats")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var chats []Chat
	for rows.Next() {
		var chat Chat
		err := rows.Scan(&chat.ChatID, &chat.Name)
		if err != nil {
			return nil, err
		}
		chats = append(chats, chat)
	}

	return chats, nil
}

func (a *StorageSQLiteAdapter) GetUsername(peerID, chatID string) (string, error) {
	row := a.db.QueryRow("SELECT username FROM ChatMembers WHERE peer_id = ? AND chat_id = ?", peerID, chatID)

	var username string
	err := row.Scan(&username)
	if err != nil {
		return "", err
	}

	return username, nil
}

type User struct {
	PeerID   string
	ChatID   string
	Username string
}

func (a *StorageSQLiteAdapter) GetUsersInChat(chatID string) ([]User, error) {
	rows, err := a.db.Query("SELECT peer_id, chat_id, username FROM ChatMembers WHERE chat_id = ?", chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var users []User
	for rows.Next() {
		var user User
		err := rows.Scan(&user.PeerID, &user.ChatID, &user.Username)
		if err != nil {
			return nil, err
		}
		users = append(users, user)
	}

	return users, nil
}

func (a *StorageSQLiteAdapter) GetPeers() ([]string, error) {
	rows, err := a.db.Query("SELECT public_key FROM Peers")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var peers []string
	for rows.Next() {
		var peer string
		err := rows.Scan(&peer)
		if err != nil {
			return nil, err
		}
		peers = append(peers, peer)
	}

	return peers, nil
}

func (a *StorageSQLiteAdapter) GetChatMessages(chatID string) ([]network.Message, error) {
	rows, err := a.db.Query(`
		SELECT m.message_id, m.content, m.date, m.operation, p.public_key, m.chat_id, p2.public_key, m.sender_address, m.receiver_address
		FROM Messages m, Peers p, Peers p2
		WHERE chat_id = ? AND m.sender_peer_id = p.peer_id AND m.receiver_peer_id = p2.peer_id
	`, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var messages []network.Message
	for rows.Next() {
		var message network.Message
		err := rows.Scan(
			&message.Id, &message.Content, &message.Timestamp, &message.Operation, &message.SenderID, &message.ChatID, &message.ReceiverID,
			&message.SenderAddress, &message.ReceiverAddress,
		)
		if err != nil {
			return nil, err
		}
		messages = append(messages, message)
	}

	return messages, nil
}

func (a *StorageSQLiteAdapter) JoinChat(peerID, chatID string, invitationID int) error {
	// Check if the invitation exists and get the chat name
	var chatName string
	err := a.db.QueryRow("SELECT m.chat_id, c.name FROM Invitations i JOIN Messages m ON i.message_id = m.message_id JOIN Chats c ON m.chat_id = c.chat_id WHERE i.invitation_id = ? AND i.invitation_status = 0", invitationID).Scan(&chatID, &chatName)
	if err != nil {
		if err == sql.ErrNoRows {
			return fmt.Errorf("invitation not found or already accepted")
		}
		return err
	}

	// Check if the chat exists, and create it if not
	err = a.createChatIfNotExists(chatID, chatName)
	if err != nil {
		return err
	}

	// Check if the peer exists, and insert if not
	err = a.insertPeerIfNotExists(peerID, "")
	if err != nil {
		return err
	}

	// Insert the peer into the chat
	stmt, err := a.db.Prepare(`
        INSERT INTO ChatMembers (date, peer_id, chat_id)
        SELECT datetime('now'), (SELECT peer_id FROM Peers WHERE public_key = ?), ?
        WHERE NOT EXISTS (SELECT 1 FROM ChatMembers WHERE peer_id = (SELECT peer_id FROM Peers WHERE public_key = ?) AND chat_id = ?)
    `)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(peerID, chatID, peerID, chatID)
	if err != nil {
		return err
	}

	// Update the invitation status
	_, err = a.db.Exec("UPDATE Invitations SET invitation_status = 1 WHERE invitation_id = ?", invitationID)
	return err
}

func (a *StorageSQLiteAdapter) createChatIfNotExists(chatID, chatName string) error {
	stmt, err := a.db.Prepare(`
        INSERT INTO Chats (chat_id, name)
        SELECT ?, ?
        WHERE NOT EXISTS (SELECT 1 FROM Chats WHERE chat_id = ?)
    `)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(chatID, chatName, chatID)
	return err
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/adapter/out/storage/storageSQLiteAdapter/createTables.sql:

CREATE TABLE IF NOT EXISTS Chats (
    chat_id VARCHAR(1024) NOT NULL CONSTRAINT Chats_pk PRIMARY KEY,
    name VARCHAR(40) NOT NULL
);

CREATE TABLE IF NOT EXISTS Peers (
    peer_id INTEGER NOT NULL CONSTRAINT Peers_pk PRIMARY KEY AUTOINCREMENT,
    public_key VARCHAR(1024) NOT NULL,
    address VARCHAR(1024) NOT NULL
);

CREATE TABLE IF NOT EXISTS ChatMembers (
    chat_member_id INTEGER NOT NULL CONSTRAINT ChatMembers_pk PRIMARY KEY AUTOINCREMENT,
    date INTEGER NOT NULL,
    peer_id VARCHAR(1024) NOT NULL CONSTRAINT ChatMembers_Peers_peer_id_fk REFERENCES Peers ON UPDATE CASCADE,
    chat_id VARCHAR(1024) NOT NULL CONSTRAINT ChatMembers_Chats_chat_id_fk REFERENCES Chats ON UPDATE CASCADE,
    username VARCHAR(50)
);

CREATE TABLE IF NOT EXISTS Messages (
    message_id VARCHAR(1024) NOT NULL CONSTRAINT Messages_pk PRIMARY KEY,
    content TEXT,
    date INTEGER NOT NULL,
    operation INTEGER NOT NULL,
    sender_peer_id VARCHAR(1024) NOT NULL CONSTRAINT Messages_Peers_peer_id_fk REFERENCES Peers ON UPDATE CASCADE,
    chat_id VARCHAR(1024) NOT NULL CONSTRAINT Messages_Chats_chat_id_fk REFERENCES Chats ON UPDATE CASCADE,
    receiver_peer_id VARCHAR(1024) NOT NULL CONSTRAINT Messages_Peers_peer_id_fk_2 REFERENCES Peers,
    sender_address VARCHAR(1024) NOT NULL,
    receiver_address VARCHAR(1024) NOT NULL
);

CREATE TABLE IF NOT EXISTS Invitations (
    invitation_id INTEGER NOT NULL CONSTRAINT Invitations_pk PRIMARY KEY AUTOINCREMENT,
    invitation_status INTEGER NOT NULL,
    message_id VARCHAR(1024) NOT NULL CONSTRAINT Invitations_Messages_message_id_fk REFERENCES Messages
);

CREATE TABLE IF NOT EXISTS PeersInInvitedChat (
    public_key VARCHAR(1024) NOT NULL,
    invited_peer_id INTEGER NOT NULL CONSTRAINT PeersInInvitedChat_pk PRIMARY KEY AUTOINCREMENT,
    address VARCHAR(1024) NOT NULL,
    invitation_id INTEGER NOT NULL CONSTRAINT PeersInInvitedChat_Invitations_invitation_id_fk REFERENCES Invitations
);


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/chat/chatLogicInterface.go:

package chat

type ChatLogic interface {
	RecieveMessage(senderId string, chatId string, message string) error
	ReceiveChatInvitation(senderId string, chatId string, chatName string, chatMembers []string) error
	PeerLeavesChat(senderId string, chatId string) error
	PeerJoinsChat(senderId string, chatId string) error
	ReceiveFile(senderId string, chatId string, filePath string) error
	PeerSetsUsername(senderId string, chatId string, username string) error
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/chat/c_model/chat.go:

package c_model

type Chat struct {
	chatId string
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/chat/c_model/user.go:

package c_model

type User struct {
	UserId   string
	Username string
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/chat/c_service/chatApp.go:

package c_service

import (
	"github.com/scherzma/Skunk/cmd/skunk/application/port/frontend"
	"sync"
)

type ChatApp struct {
	frontends []frontend.Frontend
}

var (
	chatService *ChatApp
	once        sync.Once
)

func GetChatServiceInstance() *ChatApp {
	once.Do(func() {
		chatService = &ChatApp{
			frontends: []frontend.Frontend{},
		}
	})

	return chatService
}

// FrontendObserver: Gets notified when a frontend sends a message to the chat
func (c *ChatApp) Notify(message frontend.FrontendMessage) error {
	// TODO: Implement
	return nil
}

func (c *ChatApp) AddFrontend(frontend frontend.Frontend) {
	c.frontends = append(c.frontends, frontend)
}

func (c *ChatApp) RemoveFrontend(frontend frontend.Frontend) {
	for i, f := range c.frontends {
		if f == frontend {
			c.frontends = append(c.frontends[:i], c.frontends[i+1:]...)
			return
		}
	}
}

func (c *ChatApp) SendMessageToAllFrontends(message frontend.FrontendMessage) {
	for _, f := range c.frontends {
		f.SendToFrontend(message)
	}
}

func (c *ChatApp) ProcessMessageForUser(message frontend.FrontendMessage) error {
	// TODO: Implement
	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/networkLogicInterface.go:

package p2p_network

type NetworkLogic interface {
	CreateChat(chatId string, chatName string) error
	JoinChat(chatId string) error
	LeaveChat(chatId string) error
	InviteToChat(chatId string, peerId string) error
	SendFileToChat(chatId string, filePath string) error
	SetUsernameInChat(chatId string, username string) error
	SendMessageToChat(chatId string, message string) error
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_model/networkChatMessageRepository.go:

package p_model

import (
	"errors"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

type NetworkChatMessages struct {
	chatName        string
	chatMessagesMap map[string]network.Message
}

func NewNetworkChatMessages() *NetworkChatMessages {
	return &NetworkChatMessages{
		chatMessagesMap: make(map[string]network.Message),
	}
}

func (ncm *NetworkChatMessages) AddMessage(message network.Message) error {
	if _, exists := ncm.chatMessagesMap[message.Id]; exists {
		return errors.New("message already exists")
	}

	ncm.chatMessagesMap[message.Id] = message
	return nil
}

func (ncm *NetworkChatMessages) GetMessages() []network.Message {
	messages := make([]network.Message, 0, len(ncm.chatMessagesMap))
	for _, message := range ncm.chatMessagesMap {
		messages = append(messages, message)
	}
	return messages
}

func (ncm *NetworkChatMessages) GetMissingExternalMessages(inputMessageIDs []string) []network.Message {
	missingMessages := make([]network.Message, 0)
	inputMap := make(map[string]bool)

	// Convert input slice to map for efficient lookup
	for _, id := range inputMessageIDs {
		inputMap[id] = true
	}

	for _, message := range ncm.chatMessagesMap {
		if !inputMap[message.Id] {
			missingMessages = append(missingMessages, message)
		}
	}
	return missingMessages
}

func (ncm *NetworkChatMessages) GetMissingInternalMessages(inputMessageIDs []string) []network.Message {
	missingMessages := make([]network.Message, 0)
	ncmMap := ncm.chatMessagesMap

	for _, id := range inputMessageIDs {
		if message, exists := ncmMap[id]; !exists {
			missingMessages = append(missingMessages, message)
		}
	}
	return missingMessages
}

func (ncm *NetworkChatMessages) GetMissingInternalMessageIDs(inputMessageIDs []string) []string {
	missingMessageIDs := make([]string, 0)
	ncmMap := ncm.chatMessagesMap

	for _, id := range inputMessageIDs {
		if _, exists := ncmMap[id]; !exists {
			missingMessageIDs = append(missingMessageIDs, id)
		}
	}
	return missingMessageIDs
}

func (ncm *NetworkChatMessages) GetUsername() string {
	return "todo: implement me (Username)" // TODO implement me
}

func (ncm *NetworkChatMessages) GetChatName() string {
	return ncm.chatName
}

func (ncm *NetworkChatMessages) SetChatName(chatName string) {
	ncm.chatName = chatName
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_model/networkChatRepository.go:

package p_model

type NetworkChats struct {
	chatMap map[string]NetworkChatMessages
}

var instance *NetworkChats

func GetNetworkChatsInstance() *NetworkChats {
	if instance == nil {
		instance = &NetworkChats{
			chatMap: make(map[string]NetworkChatMessages),
		}
	}
	return instance
}

func (n *NetworkChats) AddChat(chatId string) {
	if _, ok := n.chatMap[chatId]; ok {
		return
	}
	n.chatMap[chatId] = *NewNetworkChatMessages()
}

func (n *NetworkChats) GetChat(chatId string) NetworkChatMessages {
	if _, exists := n.chatMap[chatId]; !exists { //TODO change default behavior; probably should not create a new chat if it does not exist
		n.AddChat(chatId)
	}
	return n.chatMap[chatId]
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/securityService.go:

package p_service

import "github.com/scherzma/Skunk/cmd/skunk/application/port/network"

type SecurityContext struct {
}

// SecurityContext is a service that provides security checks for the network
// It should be possible to implement all security checks in this service

func (s *SecurityContext) ValidateOutgoingMessage(message network.Message) bool {
	return true
}

func (s *SecurityContext) ValidateIncomingMessage(message network.Message) bool {
	return true
}

func (s *SecurityContext) ValidatePeer(peer string) bool {
	return true
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers/inviteToChatHandler.go:

package messageHandlers

import (
	"encoding/json"
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/chat"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/store"
)

// This Peer gets invited to a chat
type InviteToChatHandler struct {
	userChatLogic         chat.ChatLogic
	chatInvitationStorage store.ChatInvitationStoragePort
}

func (i *InviteToChatHandler) HandleMessage(message network.Message) error {

	// Structure of the message:
	/*
		{
			"chatId": "asdf",
			"chatName": "asdf",
			"peers": [
				"asdf",
				"asdf"
			]
		}
	*/

	var content struct {
		ChatID   string `json:"chatId"`
		ChatName string `json:"chatName"`
		Peers    []string
	}

	err := json.Unmarshal([]byte(message.Content), &content)
	if err != nil {
		fmt.Println("Error unmarshalling message content")
		return err
	}

	i.userChatLogic.ReceiveChatInvitation(message.SenderID, content.ChatID, content.ChatName, content.Peers)

	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers/joinChatHandler.go:

package messageHandlers

import (
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/chat"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

// A Peer joins a chat
type JoinChatHandler struct {
	userChatLogic chat.ChatLogic
}

func (j *JoinChatHandler) HandleMessage(message network.Message) error {

	j.userChatLogic.PeerJoinsChat(message.SenderID, message.ChatID)
	//TODO make the necessary changes to the chat (SQLite (with interface of course))

	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers/leaveChatHandler.go:

package messageHandlers

import (
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/chat"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

// A Peer leaves a chat
type LeaveChatHandler struct {
	userChatLogic chat.ChatLogic
}

func (l *LeaveChatHandler) HandleMessage(message network.Message) error {

	l.userChatLogic.PeerLeavesChat(message.SenderID, message.ChatID)
	//TODO make the necessary changes to the chat (SQLite (with interface of course))

	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers/messageHandlerInterface.go:

package messageHandlers

import "github.com/scherzma/Skunk/cmd/skunk/application/port/network"

type MessageHandler interface {
	HandleMessage(message network.Message) error
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers/peer.go:

package messageHandlers

import (
	"errors"
	"github.com/scherzma/Skunk/cmd/skunk/adapter/out/storage/storageSQLiteAdapter"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/p2p_network/p_model"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/p2p_network/p_service"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"sync"
)

var (
	peerInstance *Peer
	once         sync.Once
)

type Peer struct {
	Chats           p_model.NetworkChats
	handlers        map[network.OperationType]MessageHandler
	connections     []network.NetworkConnection
	securityContext p_service.SecurityContext
}

func GetPeerInstance() *Peer {
	once.Do(func() {
		handlers := map[network.OperationType]MessageHandler{
			network.JOIN_CHAT:      &JoinChatHandler{},
			network.SEND_FILE:      &SendFileHandler{},
			network.SYNC_REQUEST:   &SyncRequestHandler{},
			network.SYNC_RESPONSE:  &SyncResponseHandler{},
			network.SET_USERNAME:   &SetUsernameHandler{},
			network.SEND_MESSAGE:   &SendMessageHandler{},
			network.INVITE_TO_CHAT: &InviteToChatHandler{},
			network.LEAVE_CHAT:     &LeaveChatHandler{},
			network.TEST_MESSAGE:   &TestMessageHandler{},
			network.TEST_MESSAGE_2: &TestMessageHandler2{},
		}

		peerInstance = &Peer{
			Chats:           p_model.NetworkChats{},
			handlers:        handlers,
			connections:     []network.NetworkConnection{},
			securityContext: p_service.SecurityContext{},
		}
	})

	return peerInstance
}

func (p *Peer) AddNetworkConnection(connection network.NetworkConnection) {
	p.connections = append(p.connections, connection)
	connection.SubscribeToNetwork(p)
}

func (p *Peer) RemoveNetworkConnection(connection network.NetworkConnection) {
	for i, c := range p.connections {
		if c == connection {
			p.connections = append(p.connections[:i], p.connections[i+1:]...)
			connection.UnsubscribeFromNetwork(p)
			break
		}
	}
}

func (p *Peer) Notify(message network.Message) error {
	if handler, exists := p.handlers[message.Operation]; exists {
		if !p.securityContext.ValidateIncomingMessage(message) {
			return errors.New("invalid message")
		}

		storage := storageSQLiteAdapter.NewStorageSQLiteAdapter("test.db")
		storage.StoreMessage(message)
		return handler.HandleMessage(message)
	}
	return errors.New("invalid message operation")
}

func (p *Peer) SendMessageToNetworkPeer(address string, message network.Message) error {

	if !p.securityContext.ValidateOutgoingMessage(message) {
		return errors.New("invalid message")
	}

	for _, connection := range p.connections {
		if err := connection.SendMessageToNetworkPeer(address, message); err != nil {
			return err
		}
	}
	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers/sendFileHandler.go:

package messageHandlers

import (
	"encoding/json"
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/chat"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

// A Peer sends a file to a chat
type SendFileHandler struct {
	userChatLogic chat.ChatLogic
}

func (s *SendFileHandler) HandleMessage(message network.Message) error {

	// Structure of the message:
	/*
		{
			"fileContent": []byte("asdfasdfasdf"),
		}
	*/

	var content struct {
		FileContent []byte `json:"fileContent"`
	}

	err := json.Unmarshal([]byte(message.Content), &content)
	if err != nil {
		fmt.Println("Error unmarshalling message content")
		return err
	}

	s.userChatLogic.ReceiveFile(message.SenderID, message.ChatID, string(content.FileContent))
	//TODO that's not the right way to do it
	// The file should be stored in a file system
	// Also "ReceiveFile" should receive the file path instead of the file content

	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers/sendMessageHandler.go:

package messageHandlers

import (
	"encoding/json"
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/chat"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

type SendMessageHandler struct {
	userChatLogic chat.ChatLogic
}

func (s *SendMessageHandler) HandleMessage(message network.Message) error {

	// Structure of the message:
	/*
		{
			"message": "asdfasdfasdf",
		}
	*/

	var content struct {
		Message string `json:"message"`
	}

	err := json.Unmarshal([]byte(message.Content), &content)
	if err != nil {
		fmt.Println("Error unmarshalling message content")
		return err
	}

	s.userChatLogic.RecieveMessage(message.SenderID, message.ChatID, content.Message)

	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers/setUsernameHandler.go:

package messageHandlers

import (
	"encoding/json"
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/chat"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

type SetUsernameHandler struct {
	userChatLogic chat.ChatLogic
}

func (s *SetUsernameHandler) HandleMessage(message network.Message) error {

	// Structure of the message:
	/*
		{
			"message": "asdfasdfasdf",
		}
	*/

	var content struct {
		Username string `json:"username"`
	}

	err := json.Unmarshal([]byte(message.Content), &content)
	if err != nil {
		fmt.Println("Error unmarshalling message content")
		return err
	}

	s.userChatLogic.PeerSetsUsername(message.SenderID, message.ChatID, content.Username)

	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers/syncRequestHandler.go:

package messageHandlers

import (
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/p2p_network/p_model"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"time"
)

type SyncRequestHandler struct {
}

func (s *SyncRequestHandler) HandleMessage(message network.Message) error {

	chatRepo := p_model.GetNetworkChatsInstance()
	chatMessageRepo := chatRepo.GetChat(message.ChatID)

	// Parse the content of the message
	/*
		{
		  "existingMessageIds": [
			"<message id 1>",
			"<message id 2>",
			...
		  ]
		}
	*/

	var content struct {
		ExistingMessageIDs []string `json:"existingMessageIds"`
	}
	err := json.Unmarshal([]byte(message.Content), &content)
	if err != nil {
		fmt.Println("Error unmarshalling message content")
		return err
	}

	// Find difference between "message" already known messages and own messages that the other peer does not know
	missingExternalMessages := chatMessageRepo.GetMissingExternalMessages(content.ExistingMessageIDs)
	missingInternalMessages := chatMessageRepo.GetMissingInternalMessageIDs(content.ExistingMessageIDs)

	// Convert missingExternalMessages to a JSON string
	externalMessagesBytes, err := json.Marshal(missingExternalMessages)
	if err != nil {
		fmt.Println("Error marshalling missing external messages")
		return err
	}

	// Convert missingInternalMessages to a JSON string
	internalMessagesBytes, err := json.Marshal(missingInternalMessages)
	if err != nil {
		fmt.Println("Error marshalling missing internal messages")
		return err
	}

	// Send the sync response to the other peer
	syncResponse := network.Message{
		Id:              uuid.New().String(),
		Timestamp:       time.Now().UnixNano(),
		Content:         string(externalMessagesBytes),
		SenderID:        chatMessageRepo.GetUsername(), // TODO: change
		ReceiverID:      message.SenderID,              // TODO: change
		SenderAddress:   message.SenderAddress,         // TODO: change
		ReceiverAddress: message.ReceiverAddress,       // TODO: change
		ChatID:          message.ChatID,
		Operation:       network.SYNC_RESPONSE,
	}

	// Send sync request to other peer to get the difference between the messages that the other peer knows this peer does not know
	syncRequest := network.Message{
		Id:              uuid.New().String(),
		Timestamp:       time.Now().UnixNano(),
		Content:         string(internalMessagesBytes),
		SenderID:        chatMessageRepo.GetUsername(),
		ReceiverID:      message.ReceiverID,
		SenderAddress:   message.SenderAddress,
		ReceiverAddress: message.ReceiverAddress,
		ChatID:          message.ChatID,
		Operation:       network.SYNC_REQUEST,
	}

	peer := GetPeerInstance()
	peer.SendMessageToNetworkPeer("addressResponse", syncResponse)
	peer.SendMessageToNetworkPeer("addressRequest", syncRequest)

	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers/syncResponseHandler.go:

package messageHandlers

import (
	"encoding/json"
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/p2p_network/p_model"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

type SyncResponseHandler struct {
}

func (s *SyncResponseHandler) HandleMessage(message network.Message) error {

	chatRepo := p_model.GetNetworkChatsInstance()
	chatMessageRepo := chatRepo.GetChat(message.ChatID)

	var receivedMessages []network.Message
	err := json.Unmarshal([]byte(message.Content), &receivedMessages)
	if err != nil {
		fmt.Println("Error unmarshalling message content")
		return err
	}

	for _, message := range receivedMessages {
		chatMessageRepo.AddMessage(message)
	}

	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers/testMessage2Handler.go:

package messageHandlers

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

type TestMessageHandler2 struct {
}

func (t *TestMessageHandler2) HandleMessage(message network.Message) error {
	fmt.Println("TestMessageHandler_2: ", message.Content)
	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers/testMessageHandler.go:

package messageHandlers

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
)

type TestMessageHandler struct {
}

func (t *TestMessageHandler) HandleMessage(message network.Message) error {

	fmt.Println("TestMessageHandler: ", message.Content)
	return nil
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/port/network/networkInteractionPort.go:

package network

type OperationType int

const (
	SEND_MESSAGE   OperationType = iota
	SYNC_REQUEST   OperationType = iota
	SYNC_RESPONSE  OperationType = iota
	JOIN_CHAT      OperationType = iota
	LEAVE_CHAT     OperationType = iota
	INVITE_TO_CHAT OperationType = iota
	SEND_FILE      OperationType = iota
	SET_USERNAME   OperationType = iota
	TEST_MESSAGE   OperationType = iota
	TEST_MESSAGE_2 OperationType = iota
)

type Message struct {
	Id              string
	Timestamp       int64
	Content         string
	SenderID        string
	ReceiverID      string
	SenderAddress   string
	ReceiverAddress string
	ChatID          string
	Operation       OperationType
}

type NetworkObserver interface {
	Notify(message Message) error
}

type NetworkConnection interface {
	SubscribeToNetwork(observer NetworkObserver) error
	UnsubscribeFromNetwork(observer NetworkObserver) error
	SendMessageToNetworkPeer(address string, message Message) error
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/port/frontend/frontendPort.go:

package frontend

type FrontendMessage struct {
	Timestamp int64
	Content   string
	FromUser  string // UserID
	ChatID    string // ChatID
	Operation OperationType
}

type OperationType int

const (
	SEND_MESSAGE   OperationType = iota
	CREATE_CHAT    OperationType = iota
	JOIN_CHAT      OperationType = iota
	LEAVE_CHAT     OperationType = iota
	INVITE_TO_CHAT OperationType = iota
	SEND_FILE      OperationType = iota
	SET_USERNAME   OperationType = iota
	TEST_MESSAGE   OperationType = iota
)

type FrontendObserver interface {
	Notify(message FrontendMessage) error
}

type Frontend interface {
	SubscribeToFrontend(observer FrontendObserver) error
	UnsubscribeFromFrontend(observer FrontendObserver) error
	SendToFrontend(message FrontendMessage) error // TODO: change to FrontendMessage
}


------ /home/user/GolandProjects/Skunk/cmd/skunk/application/port/store/storagePort.go:

package store

import "github.com/scherzma/Skunk/cmd/skunk/application/port/network"

type UserMessageStoragePort interface {
	PeerSetUsername(peerId string, chatId string, username string) error
}

type ChatActionStoragePort interface {
	PeerJoinedChat(peerId string, chatId string) error
	PeerLeftChat(peerId string, chatId string, senderId string, date int64) error
	ChatCreated(chatName string, chatId string) error
}

type ChatInvitationStoragePort interface {
	InvitatedToChat(chatId string, chatName string, peers []string) error
	PeerGotInvitedToChat(peerId string, chatId string) error
	GetInvitations(peerId string) []string
}

type SyncStoragePort interface {
	GetMissingInternalMessages(chatId string, inputMessageIDs []string) []string
	GetMissingExternalMessages(chatId string, inputMessageIDs []string) []string
}

type NetworkMessageStoragePort interface {
	StoreMessage(message network.Message) error
	RetrieveMessage(messageId string) (network.Message, error)
}

type ChatMessage struct {
	Username  string
	Content   string
	MessageId int64
	Timestamp int64
}

type Chat struct {
	ChatId   string
	ChatName string
}

type User struct {
	UserId   string
	Username string
}

type DisplayStoragePort interface {
	GetChats() []Chat
	GetUsername(peerId string, chatId string) string
	GetUsersInChat(chatId string) []User
	GetPeers() []string
	GetChatMessages(chatId string) []ChatMessage
}


------ /home/user/GolandProjects/Skunk/test/networkChatMessageRepository_test.go:

package test

import (
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/p2p_network/p_model"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/stretchr/testify/assert"
	"testing"
)

// WIP

func setup() (*p_model.NetworkChatMessages, network.Message, network.Message, network.Message, network.Message) {
	ncm := p_model.NewNetworkChatMessages()

	message1 := network.Message{
		Id:              "1",
		Timestamp:       1633029442,
		Content:         "{\"message\": \"Hello, user2!\"}",
		SenderID:        "user1",
		ReceiverID:      "user2",
		SenderAddress:   "user1.onion",
		ReceiverAddress: "user2.onion",
		ChatID:          "chat1",
		Operation:       network.SEND_MESSAGE,
	}
	message2 := network.Message{
		Id:              "2",
		Timestamp:       1633029443,
		Content:         "{\"message\": \"Hello, user1!\"}",
		SenderID:        "user2",
		ReceiverID:      "user1",
		SenderAddress:   "user2.onion",
		ReceiverAddress: "user1.onion",
		ChatID:          "chat1",
		Operation:       network.SEND_MESSAGE,
	}
	message3 := network.Message{
		Id:              "3",
		Timestamp:       1633029444,
		Content:         "{\"message\": \"Hello, user3!\"}",
		SenderID:        "user1",
		ReceiverID:      "user3",
		SenderAddress:   "user1.onion",
		ReceiverAddress: "user3.onion",
		ChatID:          "chat2",
		Operation:       network.SEND_MESSAGE,
	}
	message4 := network.Message{
		Id:              "4",
		Timestamp:       1633029445,
		Content:         "{\"message\": \"Hello, user4!\"}",
		SenderID:        "user2",
		ReceiverID:      "user4",
		SenderAddress:   "user2.onion",
		ReceiverAddress: "user4.onion",
		ChatID:          "chat3",
		Operation:       network.SEND_MESSAGE,
	}

	return ncm, message1, message2, message3, message4
}

func TestAddMessage(t *testing.T) {
	ncm, message1, _, _, _ := setup()

	err := ncm.AddMessage(message1)
	assert.Nil(t, err)

	err = ncm.AddMessage(message1)
	assert.NotNil(t, err)
}

func TestGetMessages(t *testing.T) {
	ncm, message1, message2, _, _ := setup()

	_ = ncm.AddMessage(message1)
	_ = ncm.AddMessage(message2)

	messages := ncm.GetMessages()
	assert.Equal(t, 2, len(messages))
	assert.Contains(t, messages, message1)
	assert.Contains(t, messages, message2)
}

func TestGetMissingExternalMessages(t *testing.T) {
	ncm, message1, message2, _, _ := setup()

	_ = ncm.AddMessage(message1)

	missingExternal := ncm.GetMissingExternalMessages([]string{message2.Id})
	assert.Equal(t, 1, len(missingExternal))
	assert.Contains(t, missingExternal, message1)

	missingExternal = ncm.GetMissingExternalMessages([]string{message1.Id, message2.Id})
	assert.Equal(t, 0, len(missingExternal))
}

func TestGetMissingInternalMessages(t *testing.T) {
	ncm, message1, message2, message3, message4 := setup()

	_ = ncm.AddMessage(message1)
	_ = ncm.AddMessage(message3)

	missingInternal := ncm.GetMissingInternalMessages([]string{message4.Id})
	assert.Equal(t, 1, len(missingInternal))
	assert.Contains(t, missingInternal, message4)

	missingInternal = ncm.GetMissingInternalMessages([]string{message1.Id, message2.Id, message3.Id, message4.Id})
	assert.Equal(t, 2, len(missingInternal))
	assert.Contains(t, missingInternal, message2)
	assert.Contains(t, missingInternal, message4)
}


------ /home/user/GolandProjects/Skunk/test/peerNetworkConnection_test.go:

package test

import (
	"github.com/scherzma/Skunk/cmd/skunk/adapter/in/networkMockAdapter"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestGetPeerInstance(t *testing.T) {
	peer1 := messageHandlers.GetPeerInstance()
	peer2 := messageHandlers.GetPeerInstance()

	if peer1 != peer2 {
		t.Errorf("GetPeerInstance() failed, expected same instance, got different instances")
	}
}

func TestNotify(t *testing.T) {
	peer := messageHandlers.GetPeerInstance()

	testMessage := network.Message{
		Id:              "8888",
		Timestamp:       1633029445,
		Content:         "Hello World!",
		SenderID:        "user1",
		ReceiverID:      "user2",
		SenderAddress:   "user1.onion",
		ReceiverAddress: "user2.onion",
		ChatID:          "chat1",
		Operation:       network.TEST_MESSAGE,
	}

	err := peer.Notify(testMessage)

	assert.NoError(t, err, "Notify() failed, expected nil, got error")

}

func TestSubscribeAndUnsubscribeToNetwork(t *testing.T) {
	mockConnection := networkMockAdapter.GetMockConnection()
	peer := messageHandlers.GetPeerInstance()

	err := mockConnection.SubscribeToNetwork(peer)
	assert.NoError(t, err, "SubscribeToNetwork() failed, expected nil, got error")

	err = mockConnection.UnsubscribeFromNetwork(peer)
	assert.NoError(t, err, "UnsubscribeFromNetwork() failed, expected nil, got error")
}


------ /home/user/GolandProjects/Skunk/test/peer_test.go:

package test

import (
	"context"
	"fmt"
	"testing"
	"time"

	"nhooyr.io/websocket"

	"github.com/scherzma/Skunk/cmd/skunk/adapter/in/peer"
	"github.com/scherzma/Skunk/cmd/skunk/adapter/in/tor"
	"github.com/stretchr/testify/assert"
)

const (
	waitTime = 1 * time.Second
)

func TestNewPeer(t *testing.T) {
	peerInstance, err := peer.NewPeer("127.0.0.1", "8080", "", "")
	assert.NoError(t, err)
	assert.NotNil(t, peerInstance)
	assert.Equal(t, peerInstance.Hostname, "127.0.0.1")
	assert.Equal(t, peerInstance.Port, "8080")
	assert.Equal(t, peerInstance.ProxyAddr, "")
}

func TestListen(t *testing.T) {
	peerInstance, err := peer.NewPeer("127.0.0.1", "8080", "", "")
	defer peerInstance.Shutdown()
	assert.NoError(t, err)

	peerInstance.Listen(nil)
	time.Sleep(waitTime)

	// Connecting to peer address should work
	conn, _, err := websocket.Dial(context.Background(), "ws://127.0.0.1:8080", nil)
	assert.NoError(t, err)
	assert.NotNil(t, conn)

	conn.Close(websocket.StatusNormalClosure, "test completed")
}

func TestConnect(t *testing.T) {
	peer1, err := peer.NewPeer("127.0.0.1", "1234", "", "")
	defer peer1.Shutdown()
	peer2, err := peer.NewPeer("127.0.0.1", "4321", "", "")
	defer peer2.Shutdown()

	peer1.Listen(nil)
	peer2.Listen(nil)
	time.Sleep(waitTime)

	// First connect from peer1 to peer2.
	err = peer1.Connect(peer2.Address)
	assert.NoError(t, err)

	// Second connect from peer1 to peer2 should return an error because they have already been connected.
	err = peer1.Connect(peer2.Address)
	assert.Error(t, err)

	// Connect from peer1 to peer1 should not work.
	err = peer1.Connect(peer1.Address)
	assert.Error(t, err)

	// Connect from peer2 to peer1 should return an error because they have already been connected.
	err = peer2.Connect(peer1.Address)
	assert.Error(t, err)

	// Should return an error, because "" is not a valid address
	err = peer2.Connect("")
	assert.Error(t, err)
}

func TestPeerSetWriteConn(t *testing.T) {
	peer1, _ := peer.NewPeer("127.0.0.1", "1111", "", "")
	defer peer1.Shutdown()
	peer2, _ := peer.NewPeer("127.0.0.1", "10000", "", "")
	defer peer2.Shutdown()

	peer1.Listen(nil)
	time.Sleep(waitTime)

	err := peer2.Connect(peer1.Address)
	time.Sleep(waitTime)

	// First time setting the write conn to peer1.Address should work
	err = peer2.SetWriteConn(peer1.Address)
	assert.NoError(t, err)

	// Setting the write conn to ones own address should not work
	err = peer2.SetWriteConn(peer2.Address)
	assert.Error(t, err)

	// Setting the write conn to an address the peer is not connected to should not work
	err = peer2.SetWriteConn("ws://127.0.0.1:9999")
	assert.Error(t, err)

	// Setting the write conn to "" should not work
	err = peer2.SetWriteConn("")
	assert.Error(t, err)
}

func TestPeerReadMessages(t *testing.T) {
	peer1, _ := peer.NewPeer("127.0.0.1", "2222", "", "")
	defer peer1.Shutdown()
	peer2, _ := peer.NewPeer("127.0.0.1", "3333", "", "")
	defer peer2.Shutdown()
	peer3, _ := peer.NewPeer("127.0.0.1", "4444", "", "")
	defer peer3.Shutdown()
	peer4, _ := peer.NewPeer("127.0.0.1", "5555", "", "")
	defer peer4.Shutdown()
	peer5, _ := peer.NewPeer("127.0.0.1", "6666", "", "")
	defer peer5.Shutdown()

	peer1.Listen(nil)
	time.Sleep(1 * time.Second)

	address := peer1.Address
	peer2.Connect(address)
	peer3.Connect(address)
	peer4.Connect(address)
	peer5.Connect(address)

	messageCh := make(chan string)
	errorCh := make(chan error)
	go peer1.ReadMessages(messageCh, errorCh)

	peer2.SetWriteConn(address)
	peer3.SetWriteConn(address)
	peer4.SetWriteConn(address)
	peer5.SetWriteConn(address)

	// Reading a message from each connection should work
	peer2.WriteMessage("Hello World!")
	peer3.WriteMessage("This is the story of my life")
	peer4.WriteMessage("Just do it!")
	peer5.WriteMessage("ABCDEFGHIJKLM")

	// Reading messages from the same connections again should work
	peer2.WriteMessage("Hello Proxima Centauri!")
	peer3.WriteMessage("Are you alright?")
	peer4.WriteMessage("No I'm all left!")
	peer5.WriteMessage("XYZ")

	// Reading multiple messages from the same connection should work
	peer2.WriteMessage("Recursive ...")
	peer2.WriteMessage("Recursive ...")
	peer2.WriteMessage("Recursive ...")
	peer2.WriteMessage("Recursive ...")

	// wait until all messages have been sent and received
	time.Sleep(10 * time.Second)

	// check that no error occured in this time
	select {
	case err := <-errorCh:
		assert.NoError(t, err)
	default:
	}
}

func TestPeerWriteMessage(t *testing.T) {
	peer1, _ := peer.NewPeer("127.0.0.1", "8888", "", "")
	defer peer1.Shutdown()
	peer2, _ := peer.NewPeer("127.0.0.1", "7890", "", "")
	defer peer2.Shutdown()

	peer1.Listen(nil)
	time.Sleep(1 * time.Second)

	peer2.Connect(peer1.Address)
	peer2.SetWriteConn(peer1.Address)

	messageCh := make(chan string)
	errorCh := make(chan error)
	go peer1.ReadMessages(messageCh, errorCh)

	var tests = []struct {
		name  string
		input string
		want  string
	}{
		{"numbers", "1234567890", fmt.Sprintf("From %s: 1234567890", peer2.Address)},
		{"LETTERS", "ABCDEFGHIZ", fmt.Sprintf("From %s: ABCDEFGHIZ", peer2.Address)},
		{"letters", "abcdefghiz", fmt.Sprintf("From %s: abcdefghiz", peer2.Address)},
		{"special", "!?({&=$-:,", fmt.Sprintf("From %s: !?({&=$-:,", peer2.Address)},
		{"weird", "\t\n\r ", fmt.Sprintf("From %s: \t\n\r ", peer2.Address)},
		{"mixture", "abc123ABC!", fmt.Sprintf("From %s: abc123ABC!", peer2.Address)},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			peer2.WriteMessage(tt.input)

			select {
			case msg := <-messageCh:
				assert.Equal(t, msg, tt.want)
			case err := <-errorCh:
				assert.NoError(t, err)
			}
		})
	}
}

func TestPeerShutdown(t *testing.T) {
	peerInstance, _ := peer.NewPeer("127.0.0.1", "1111", "", "")
	defer peerInstance.Shutdown()

	peerInstance.Listen(nil)
	time.Sleep(waitTime)

	peerInstance.Shutdown()

	// After shutdown you shoudn't be able to connect to the peer
	_, _, err := websocket.Dial(context.Background(), "ws://127.0.0.1:1111", nil)
	assert.Error(t, err)

	peerInstance.Listen(nil)
	time.Sleep(waitTime)

	// After executing Listen you should be able to connect to the peer again
	conn, _, err := websocket.Dial(context.Background(), "ws://127.0.0.1:1111", nil)
	assert.NoError(t, err)
	assert.NotNil(t, conn)

	conn.Close(websocket.StatusNormalClosure, "test completed")
}

func TestPeerHeartbeat(t *testing.T) {
	peer1, _ := peer.NewPeer("127.0.0.1", "1111", "", "")
	defer peer1.Shutdown()
	peer2, _ := peer.NewPeer("127.0.0.1", "2222", "", "")

	peer1.Listen(nil)
	time.Sleep(waitTime)

	peer2.Connect(peer1.Address)
	time.Sleep(waitTime)

	peer2.Shutdown()
	time.Sleep(70 * time.Second)

	// Should not work anymore, because hearbeat removed the closed connection
	err := peer1.SetWriteConn(peer2.Address)
	assert.Error(t, err)
}

// this test represents two peers exchanging a message over the tor network
// because go-libtor can only start one tor process, we have to use one local installation of tor too
func TestPeerTor(t *testing.T) {
	// starts the non-embedded version of tor
	conf := &tor.TorConfig{
		DataDir:              "data-dir1",
		SocksPort:            "9052",
		LocalPort:            "1110",
		RemotePort:           "1111",
		DeleteDataDirOnClose: true,
		UseEmbedded:          false,
	}
	myTorOne, err := tor.NewTor(conf)
	assert.NoError(t, err)

	err = myTorOne.StartTor()
	assert.NoError(t, err)

	onionOne, err := myTorOne.StartHiddenService()
	assert.NoError(t, err)

	peerInstanceOne, _ := peer.NewPeer(onionOne.ID+".onion", "1110", "1111", "127.0.0.1:9052")
	defer peerInstanceOne.Shutdown()

	peerInstanceOne.Listen(onionOne)
	time.Sleep(1 * waitTime)

	// starts the embedded version of tor
	conf = &tor.TorConfig{
		DataDir:              "data-dir2",
		SocksPort:            "9053",
		LocalPort:            "2221",
		RemotePort:           "2222",
		DeleteDataDirOnClose: true,
		UseEmbedded:          false,
	}
	myTorTwo, err := tor.NewTor(conf)
	assert.NoError(t, err)

	err = myTorTwo.StartTor()
	assert.NoError(t, err)

	onionTwo, err := myTorTwo.StartHiddenService()
	assert.NoError(t, err)

	// wait for the hidden service to be published completely
	time.Sleep(10 * time.Second)

	peerInstanceTwo, _ := peer.NewPeer(onionTwo.ID+".onion", "2221", "2222", "127.0.0.1:9053")
	defer peerInstanceTwo.Shutdown()

	err = peerInstanceTwo.Connect(peerInstanceOne.Address)
	assert.NoError(t, err)

	peerInstanceTwo.SetWriteConn(peerInstanceOne.Address)

	messageCh := make(chan string)
	errorCh := make(chan error)

	go peerInstanceOne.ReadMessages(messageCh, errorCh)

	peerInstanceTwo.WriteMessage("Hello Dark World!")

	// wait until message has been sent and received
	time.Sleep(10 * time.Second)

	// check that no error occured during this time
	select {
	case msg := <-messageCh:
		t.Log(msg)
	case err := <-errorCh:
		assert.NoError(t, err)
	default:
	}

	myTorOne.StopTor()
	myTorTwo.StopTor()
}


------ /home/user/GolandProjects/Skunk/test/tor_test.go:

package test

import (
	"os"
	"testing"
	"time"

	"github.com/scherzma/Skunk/cmd/skunk/adapter/in/tor"
	"github.com/stretchr/testify/assert"
)

// The tests always use the embedded version of go
// since this will also be the version we'll use in production

func TestStartTor(t *testing.T) {
	conf := &tor.TorConfig{
		SocksPort:            "9070",
		LocalPort:            "1111",
		RemotePort:           "2222",
		DeleteDataDirOnClose: true,
		UseEmbedded:          false,
	}
	myTor, err := tor.NewTor(conf)
	assert.NoError(t, err)

	err = myTor.StartTor()
	assert.NoError(t, err)

	err = myTor.StopTor()
	assert.NoError(t, err)
}

func TestStartHiddenService(t *testing.T) {
	conf := &tor.TorConfig{
		SocksPort:            "9080",
		LocalPort:            "3333",
		RemotePort:           "4444",
		DeleteDataDirOnClose: true,
		UseEmbedded:          false,
	}
	myTor, err := tor.NewTor(conf)
	assert.NoError(t, err)

	err = myTor.StartTor()
	assert.NoError(t, err)

	onion, err := myTor.StartHiddenService()
	assert.NoError(t, err)
	if assert.NotNil(t, onion) {
		assert.NotNil(t, onion.LocalListener)
		assert.NotNil(t, onion.RemotePorts)
		assert.NotNil(t, onion.ID)
	}

	err = myTor.StopTor()
	assert.NoError(t, err)
}

func TestStopTor(t *testing.T) {
	dataDir := "test-data-dir"
	conf := &tor.TorConfig{
		DataDir:              dataDir,
		SocksPort:            "9090",
		LocalPort:            "5555",
		RemotePort:           "6666",
		DeleteDataDirOnClose: true,
		UseEmbedded:          false,
	}
	myTor, err := tor.NewTor(conf)
	assert.NoError(t, err)

	err = myTor.StartTor()
	assert.NoError(t, err)

	err = myTor.StopTor()
	assert.NoError(t, err)

	// the dataDir-folder shouldn't exist anymore
	_, err = os.Stat(dataDir)
	assert.True(t, os.IsNotExist(err))
}

func TestReusePrivateKeyTor(t *testing.T) {
	dataDir := "reuse-data-dir"
	// configure tor to reuse the private key
	conf := &tor.TorConfig{
		DataDir:              dataDir,
		SocksPort:            "9100",
		LocalPort:            "1234",
		RemotePort:           "4321",
		DeleteDataDirOnClose: false,
		ReusePrivateKey:      true,
		UseEmbedded:          false,
	}
	myTor, err := tor.NewTor(conf)
	assert.NoError(t, err)

	err = myTor.StartTor()
	assert.NoError(t, err)

	onionOne, err := myTor.StartHiddenService()
	assert.NoError(t, err)

	onionIDOne := onionOne.ID

	err = myTor.StopTor()
	assert.NoError(t, err)

	time.Sleep(5 * time.Second)

	// restart tor hidden service
	// and check if onionID is the same as before
	conf = &tor.TorConfig{
		DataDir:              dataDir,
		SocksPort:            "9100",
		LocalPort:            "5678",
		RemotePort:           "1010",
		DeleteDataDirOnClose: true,
		ReusePrivateKey:      true,
		UseEmbedded:          false,
	}
	myTor, err = tor.NewTor(conf)
	assert.NoError(t, err)

	err = myTor.StartTor()
	assert.NoError(t, err)

	onionTwo, err := myTor.StartHiddenService()
	assert.NoError(t, err)

	onionIDTwo := onionTwo.ID

	err = myTor.StopTor()
	assert.NoError(t, err)

	assert.Equal(t, onionIDOne, onionIDTwo)
}


------ /home/user/GolandProjects/Skunk/test/networkAdapter_test.go:

package test

import (
	"github.com/scherzma/Skunk/cmd/skunk/adapter/in/networkMockAdapter"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"testing"
)

type MockPeer struct {
	network network.NetworkConnection
}

func (p *MockPeer) SubscribeToNetwork(network network.NetworkConnection) error {
	p.network = network
	p.network.SubscribeToNetwork(p)
	return nil
}

func (p *MockPeer) RemoveNetworkConnection(network network.NetworkConnection) {
	p.network.UnsubscribeFromNetwork(p)
	p.network = nil
}

func (p *MockPeer) Notify(message network.Message) error {
	return nil
}

func (p *MockPeer) SendMessageToNetworkPeer(address string, message network.Message) error {
	p.network.SendMessageToNetworkPeer(address, message)
	return nil
}

func TestNetworkAdapter(t *testing.T) {

	// Create a mock network connection
	testMessage := network.Message{
		Id:              "msg1",
		Timestamp:       1620000000,
		Content:         "{\"message\": \"Hey everyone!\"}",
		SenderID:        "user1",
		ReceiverID:      "user2",
		SenderAddress:   "user1.onion",
		ReceiverAddress: "user2.onion",
		ChatID:          "chat1",
		Operation:       network.SEND_MESSAGE,
	}

	peer := MockPeer{
		network: &networkMockAdapter.MockConnection{},
	}

	mockNetworkConnection := networkMockAdapter.GetMockConnection()
	peer.SubscribeToNetwork(mockNetworkConnection)

	peer.SendMessageToNetworkPeer("addressResponse", testMessage)
	mockNetworkConnection.SendMockNetworkMessageToSubscribers(testMessage)

}


------ /home/user/GolandProjects/Skunk/test/syncRequest_test.go:

package test

import (
	"github.com/scherzma/Skunk/cmd/skunk/adapter/in/networkMockAdapter"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/p2p_network/p_model"
	"github.com/scherzma/Skunk/cmd/skunk/application/domain/p2p_network/p_service/messageHandlers"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"testing"
)

func TestSyncRequestHandler(t *testing.T) {
	// Create a mock network connection
	testMessage := network.Message{
		Id:              "8888",
		Timestamp:       1633029445,
		Content:         "Hello World!",
		SenderID:        "user1",
		ReceiverID:      "user2",
		SenderAddress:   "user1.onion",
		ReceiverAddress: "user2.onion",
		ChatID:          "chat1",
		Operation:       network.TEST_MESSAGE,
	}

	peer := messageHandlers.GetPeerInstance()

	mockNetworkConnection := networkMockAdapter.GetMockConnection()
	peer.AddNetworkConnection(mockNetworkConnection)

	mockNetworkConnection.SendMockNetworkMessageToSubscribers(testMessage)

	testSyncMessage := network.Message{
		Id:              "12345",
		Timestamp:       1633029446,
		Content:         "{\"existingMessageIds\": [\"<message id 1>\",\"<message id 2>\"]}",
		SenderID:        "user1",
		ReceiverID:      "user2",
		SenderAddress:   "user1.onion",
		ReceiverAddress: "user2.onion",
		ChatID:          "chat1",
		Operation:       network.SYNC_REQUEST,
	}

	internalMessage := network.Message{
		Id:              "internalMessage123!",
		Timestamp:       1633029448,
		Content:         "LOOOOOOOOOOOOOOOOOOOOOOOL",
		SenderID:        "user3",
		ReceiverID:      "user4",
		SenderAddress:   "user3.onion",
		ReceiverAddress: "user4.onion",
		ChatID:          "chat1",
		Operation:       network.SYNC_REQUEST,
	}

	internalMessage2 := network.Message{
		Id:              "internalMessage2",
		Timestamp:       1633029448,
		Content:         "WOOW",
		SenderID:        "user3",
		ReceiverID:      "user4",
		SenderAddress:   "user3.onion",
		ReceiverAddress: "user4.onion",
		ChatID:          "chat1",
		Operation:       network.SYNC_REQUEST,
	}

	internalMessage3 := network.Message{
		Id:              "internalMessage3",
		Timestamp:       1633029448,
		Content:         "WOLOLOW",
		SenderID:        "user3",
		ReceiverID:      "user4",
		SenderAddress:   "user3.onion",
		ReceiverAddress: "user4.onion",
		ChatID:          "chat2",
		Operation:       network.SYNC_REQUEST,
	}

	chat := p_model.GetNetworkChatsInstance().GetChat(internalMessage.ChatID)
	chat.AddMessage(internalMessage)
	chat.AddMessage(internalMessage2)

	chat2 := p_model.GetNetworkChatsInstance().GetChat(internalMessage3.ChatID)
	chat2.AddMessage(internalMessage3)

	mockNetworkConnection.SendMockNetworkMessageToSubscribers(testSyncMessage)

}


------ /home/user/GolandProjects/Skunk/test/storageSQLiteAdapter_test.go:

package test

import (
	"fmt"
	"github.com/scherzma/Skunk/cmd/skunk/adapter/out/storage/storageSQLiteAdapter"
	"github.com/scherzma/Skunk/cmd/skunk/application/port/network"
	"os"
	"reflect"
	"testing"
)

func TestStorageSQLiteAdapter(t *testing.T) {
	// Create a temporary database for testing
	dbPath := "test.db"
	defer os.Remove(dbPath)

	adapter := storageSQLiteAdapter.NewStorageSQLiteAdapter(dbPath)

	testMessages := []network.Message{
		{
			Id:              "msg1",
			Timestamp:       1620000000,
			Content:         "{\"message\": \"Hey everyone!\"}",
			SenderID:        "user1",
			ReceiverID:      "user2",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "user2.onion",
			ChatID:          "chat1",
			Operation:       network.SEND_MESSAGE,
		},
		{
			Id:              "sync1",
			Timestamp:       1620000060,
			Content:         "{\"existingMessageIds\": [\"msg1\"]}",
			SenderID:        "user2",
			ReceiverID:      "user1",
			SenderAddress:   "user2.onion",
			ReceiverAddress: "user1.onion",
			ChatID:          "chat1",
			Operation:       network.SYNC_REQUEST,
		},
		{
			Id:              "sync2",
			Timestamp:       1620000120,
			Content:         "[{\"Id\":\"msg2\",\"Timestamp\":1620000090,\"Content\":\"{\\\"message\\\": \\\"Hi User1!\\\"}\",\"SenderID\":\"user3\",\"ReceiverID\":\"user1\",\"SenderAddress\":\"user3.onion\",\"ReceiverAddress\":\"user1.onion\",\"ChatID\":\"chat1\",\"Operation\":0}]",
			SenderID:        "user1",
			ReceiverID:      "user2",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "user2.onion",
			ChatID:          "chat1",
			Operation:       network.SYNC_RESPONSE,
		},
		{
			Id:              "join1",
			Timestamp:       1620000180,
			Content:         "",
			SenderID:        "user4",
			ReceiverID:      "",
			SenderAddress:   "user4.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.JOIN_CHAT,
		},
		{
			Id:              "leave1",
			Timestamp:       1620000240,
			Content:         "",
			SenderID:        "user3",
			ReceiverID:      "",
			SenderAddress:   "user3.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.LEAVE_CHAT,
		},
		{
			Id:              "invite1",
			Timestamp:       1620000300,
			Content:         "{\"chatId\": \"chat1\", \"chatName\": \"Cool Chat\", \"peers\": [\"user5.onion\", \"user6.onion\"]}",
			SenderID:        "user1",
			ReceiverID:      "",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.INVITE_TO_CHAT,
		},
		{
			Id:              "file1",
			Timestamp:       1620000360,
			Content:         "{\"fileContent\": \"aGVsbG8gd29ybGQ=\"}",
			SenderID:        "user2",
			ReceiverID:      "",
			SenderAddress:   "user2.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.SEND_FILE,
		},
		{
			Id:              "setuser1",
			Timestamp:       1620000420,
			Content:         "{\"username\": \"CoolUser1\"}",
			SenderID:        "user1",
			ReceiverID:      "",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "",
			ChatID:          "chat1",
			Operation:       network.SET_USERNAME,
		},
		{
			Id:              "test1",
			Timestamp:       1620000480,
			Content:         "This is a test message",
			SenderID:        "user1",
			ReceiverID:      "user2",
			SenderAddress:   "user1.onion",
			ReceiverAddress: "user2.onion",
			ChatID:          "chat1",
			Operation:       network.TEST_MESSAGE,
		},
		{
			Id:              "test2",
			Timestamp:       1620000540,
			Content:         "This is another test message",
			SenderID:        "user2",
			ReceiverID:      "user4",
			SenderAddress:   "user2.onion",
			ReceiverAddress: "user4.onion",
			ChatID:          "chat1",
			Operation:       network.TEST_MESSAGE_2,
		},
	}

	// Store the test messages
	for _, msg := range testMessages {
		err := adapter.StoreMessage(msg)
		if err != nil {
			t.Errorf("Error storing message: %v", err)
		}
	}

	fmt.Println("Messages stored")
	// Retrieve the messages and compare
	for _, msg := range testMessages {
		retrieved, err := adapter.RetrieveMessage(msg.Id)
		if err != nil {
			t.Errorf("Error retrieving message: %v", err)
		}
		fmt.Println(retrieved)
		fmt.Println(msg)
		if !reflect.DeepEqual(msg, retrieved) {
			t.Errorf("Retrieved message does not match stored message")
		}
	}

	// Test GetChatMessages
	chatMessages, err := adapter.GetChatMessages("chat1")
	if err != nil {
		t.Errorf("Error getting chat messages: %v", err)
	}

	if len(chatMessages) != len(testMessages) {
		t.Errorf("Expected %d chat messages, got %d", len(testMessages), len(chatMessages))
	}

	// Test SetPeerUsername
	err = adapter.SetPeerUsername("CoolUser1", "user1", "chat1")
	if err != nil {
		t.Errorf("Error setting peer username: %v", err)
	}

	username, err := adapter.GetUsername("user1", "chat1")
	if err != nil {
		t.Errorf("Error getting username: %v", err)
	}

	if username != "CoolUser1" {
		t.Errorf("Expected username 'CoolUser1', got '%s'", username)
	}

	// Additional tests can be added for other methods...
}


